<!DOCTYPE html>
<html>
  <head>
	<title>Software</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" href="github.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="README.html" alt="README">README</a></li>
<li><a href="assignments.html" alt="assignments">assignments</a></li>
<li><a href="database.html" alt="database">database</a></li>
<li><a href="index.html" alt="index">index</a></li>
<li><a href="js.html" alt="js">js</a></li>
<li><a href="nodejs.html" alt="nodejs">nodejs</a></li>
<li><a href="opendata.html" alt="opendata">opendata</a></li>
<li><a href="software.html" alt="software">software</a></li>
	</ul></nav>	
	<div id="main">
	<h1 id="software">Software</h1>
<p>The course will make use of two main technologies: the <a href="http://www.cycling74.com">Max/MSP/Jitter</a> visual data flow software environment, and modern web technologies. JavaScript is the primary language of client-side web today, and we will also use it server-side through <a href="http://nodejs.org">node.js</a>. (Moreover, JavaScript is supported in Max through the [js] object. </p>
<h2 id="max-msp-jitter">Max/MSP/Jitter</h2>
<blockquote>
<p>A full kit of creative tools for sound, graphics, music and interactivity in a visual environment.</p>
</blockquote>
<p>Max is installed on the Art &amp; Technology lab machines and licenses are available for DM students. Download an installer from <a href="https://cycling74.com/downloads/">Cycling74</a>. (Max 7 licensing for York DM will be arranged in January 2015). </p>
<h3 id="getting-static-data-into-max">Getting static data into Max</h3>
<p>[jit.fprint] will import delimited text files. The @planedelim, @coldelim and @rowdelim attributes can be used to define the format of the data expected. Note that this will only work well for data that is purely numeric and tabular. This is true for many scientific data sources. For <a href="http://en.wikipedia.org/wiki/Comma-separated_values">CSV</a> files (comma separated values):</p>
<pre><code>[jit.fprint <span class="hljs-property">@type</span> float32 <span class="hljs-property">@planedelim</span> space <span class="hljs-property">@coldelim</span> <span class="hljs-string">\,</span> <span class="hljs-property">@rowdelim</span> cr]
</code></pre><p>[dict] will import (and export) JSON and YAML files directly. Note that you can set <code>@embed 1</code> to ensure that a dict remembers its data between Max sessions. As with other objects in Max, a named dict is globally shared. And [dict] is well integrated with the [js] Javascript object:</p>
<pre><code><span class="hljs-comment">// import</span>
<span class="hljs-keyword">var</span> x = new Dict;
x.import_json(<span class="hljs-string">"dict_file.json"</span>);
<span class="hljs-keyword">post</span>(x.name, x.getkeys());

<span class="hljs-comment">// global reference:</span>
<span class="hljs-keyword">var</span> <span class="hljs-keyword">d</span> = new Dict(<span class="hljs-string">"outside"</span>);
<span class="hljs-keyword">var</span> name = <span class="hljs-keyword">d</span>.name;    <span class="hljs-comment">// "outside"</span>
<span class="hljs-keyword">var</span> names = <span class="hljs-keyword">d</span>.getnames();
<span class="hljs-keyword">var</span> keys = <span class="hljs-keyword">d</span>.getkeys();

<span class="hljs-keyword">d</span>.<span class="hljs-keyword">set</span>(<span class="hljs-string">"bologna"</span>, 1.99);
<span class="hljs-keyword">var</span> price = <span class="hljs-keyword">d</span>.<span class="hljs-literal">get</span>(<span class="hljs-string">"bologna"</span>);

<span class="hljs-keyword">var</span> there_is_coffee = <span class="hljs-keyword">d</span>.contains(<span class="hljs-string">"drink::hot::coffee"</span>);

<span class="hljs-keyword">d</span>.<span class="hljs-keyword">replace</span>(<span class="hljs-string">"drink::hot::coffee::origin", "sumatra"</span>);
<span class="hljs-keyword">d</span>.<span class="hljs-keyword">set</span>(<span class="hljs-string">"drink::hot::coffee::sizes", "small", "medium", "large"</span>);    <span class="hljs-comment">// creates array</span>
<span class="hljs-keyword">d</span>.<span class="hljs-keyword">append</span>(<span class="hljs-string">"drink::hot::coffee::sizes", "mega-grande"</span>);    <span class="hljs-comment">// extends array</span>

<span class="hljs-comment">// convert to json string:</span>
<span class="hljs-keyword">var</span> j = x.stringify();
</code></pre><p>Alternatively, using the [js] object you can just parse JSON text directly:</p>
<pre><code><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(jsontext);
</code></pre><p><a href="http://max-javascript-reference.tim-schenk.de/#gsc.tab=0">See the Max JavaScript Reference</a></p>
<blockquote>
<p>Note: Max contains an implementation of the SQLite database engine (more info available @ <a href="http://sqlite.org">http://sqlite.org</a>). This database engine is accessible through both the C-API and directly in Max through the JavaScript interface. </p>
</blockquote>
<h3 id="getting-dynamic-web-data-into-max-maxurl">Getting dynamic web data into Max: maxurl</h3>
<p>The maxurl object allows you to make HTTP requests with Max. See the maxurl help file for examples and explanation.</p>
<p>Simple GET/POST requests can be made with messages to maxurl, which will output a dict containing the response, as well as other network status updates. More structured requests can be made by sending a dict to maxurl, for the ability to parse specific response types, add arguments, proxy servers, or even save the results to disk. For more complex needs, it is possible to use JavaScript directly: the [js] object in Max supports a similar interface to maxurl (and browser-based JavaScript) through the <strong>XMLHttpRequest</strong> object. <a href="https://cycling74.com/2014/06/09/use-maxurl-to-create-a-realtime-instagram-collage/">Here&#39;s a fun example making instagram collages.</a></p>
<h3 id="examples">Examples</h3>
<ul>
<li><a href="https://cycling74.com/wiki/index.php?title=MaxURL_Weather_Report">Max + OpenWeatherMap</a></li>
<li><a href="https://cycling74.com/2014/06/09/use-maxurl-to-create-a-realtime-instagram-collage/">Max realtime instagram collage</a></li>
<li><a href="http://reactivemusic.net/?p=5859">Tom Zicarelli</a></li>
<li><a href="https://cycling74.com/2014/12/19/music-hack-for-max-7-elevator-music-generator/">Elevator Music</a></li>
</ul>
<hr>
<h2 id="web-technology">Web technology</h2>
<p><strong>Clients</strong> (browsers) make requests to <strong>servers</strong>, that respond with renderable content (mainly HTML, with embedded media and scripts). Servers (sites, services and applications) are addressable at <a href="http://en.wikipedia.org/wiki/Uniform_resource_locator">URLs</a>.</p>
<h3 id="client-side-programming-html-css-js-">Client-side programming (HTML, CSS, JS)</h3>
<p>Modern client-side web technology is a trio of HTML, CSS and <a href="js.html">JavaScript</a>, making extensive use of the new audiovisual capabilities of HTML5 including Canvas, SVG, WebGL etc. A great way to play with how it all fits together is using an online test-bed such as <a href="http://jsfiddle.net">JS Fiddle</a>.</p>
<h4 id="html">HTML</h4>
<p><a href="http://www.w3schools.com/html/">HTML</a> (HyperText Markup Language) is the standard markup language for the web. It is not a programming language, but a formatting language; the browser reads this language and uses it to render the web page. The basic document syntax:</p>
<pre><code class="lang-html"><span class="hljs-doctype">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>This is a title<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- more metadata here --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"http://www.google.com/"</span>&gt;</span>A Link to Google!<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- more content here --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<p>The indentation helps us to see that HTML has the abstract structure of a hierarchical tree. This structure is called the <a href="http://en.wikipedia.org/wiki/Document_Object_Model">DOM</a> (Document Object Model). Nodes within the tree can also be uniquely named via the <code>id</code> attribute, and classified by the <code>class</code> attribute: </p>
<pre><code class="lang-html">&lt;p <span class="hljs-property">id</span>=<span class="hljs-string">"intro"</span> <span class="hljs-type">class</span>=<span class="hljs-string">"normal"</span>&gt;Welcome <span class="hljs-keyword">to</span> HTML&lt;/p&gt;
</code></pre>
<p>IDs and classes are often used in combination with <a href="http://www.w3schools.com/css/">CSS</a> to automatically define visual styles independently of the content. The DOM, including id and class attributes, are also available to JavaScript in the browser.  </p>
<h4 id="css">CSS</h4>
<p>CSS (Cascading Stylesheets) is a language for styling HTML pages. CSS styles (also know as selectors) are typically applied to HTML tags based on their name, class, or ID. Each selector specifies a set of property values to apply. Properties can be defined for backgrounds, text, fonts, links, lists, tables, boxes, borders, outlines, margins, paddings, sizes, display modes, alignment, and more. </p>
<p>Stylesheets are embedded in the HTML&#39;s <code>&lt;head&gt;</code> tag. This can either be inline as below:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
<span class="hljs-comment">/* put styles here */</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
</code></pre><p>Or it can be imported from a separate file (multiple stylesheets can be imported this way):</p>
<pre><code>&lt;link <span class="hljs-variable">rel=</span><span class="hljs-string">"stylesheet"</span> <span class="hljs-variable">type=</span><span class="hljs-string">"text/css"</span> <span class="hljs-variable">href=</span><span class="hljs-string">"mystyle.css"</span>&gt;
</code></pre><p>The most commonly used rules for making selectors are fairly simple:</p>
<pre><code class="lang-css">
    <span class="hljs-comment">/* Applied to all &lt;p&gt; tags */</span>
    <span class="hljs-tag">p</span> {
          <span class="hljs-attribute">background-color</span>: <span class="hljs-hexcolor">#ff0000</span>;    <span class="hljs-comment">// hexadecimal color (RRGGBB)</span>
                                      <span class="hljs-comment">// can also say rgb(255,0,0)</span>
    }

    <span class="hljs-comment">/* Applied to all &lt;p&gt;, &lt;h1&gt; and &lt;h2&gt; tags */</span>
    <span class="hljs-tag">p</span>, <span class="hljs-tag">h1</span>, <span class="hljs-tag">h2</span> {
          <span class="hljs-attribute">text-align</span>: left;
    }

    <span class="hljs-comment">/* Applied to all tags with class="red" */</span>
    <span class="hljs-class">.red</span> {
          <span class="hljs-attribute">background-color</span>: red;
    }

    <span class="hljs-comment">/* Applied to &lt;p&gt; tags with class="red" */</span>
    <span class="hljs-tag">p</span><span class="hljs-class">.red</span> {
        <span class="hljs-attribute">color</span>: white;
        <span class="hljs-attribute">background-color</span>: red;
    }

    <span class="hljs-comment">/* Applied to the tag with the id="some-id" */</span>
    <span class="hljs-id">#some-id</span> {
      <span class="hljs-attribute">font-style</span>: italic;
      <span class="hljs-attribute">font-size</span>: large;
    }

    <span class="hljs-comment">/* Applied only to &lt;p&gt; tags that are inside &lt;li&gt; tags */</span>
    <span class="hljs-tag">li</span> <span class="hljs-tag">p</span> {
      <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#0C0</span>;
    }

    <span class="hljs-comment">/* Applied to &lt;a&gt; tags when the mouse is over them:
    a:hover {
        text-decoration: underline;
    }

    <span class="hljs-comment">/* Applied to all links starting with # (i.e. internal links) */</span>
    a[href^="#"] {
        background-color:gold
    }</span>
</code></pre>
<p>To know more about CSS, I recommend looking at <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started">MDN&#39;s developer guide</a>. In particular, for geometric properties (margin, padding, width/height, border) you should know about the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model">Box Model</a>.</p>
<p>Warning: css styles are not supported or rendered the same by all browsers!</p>
<h3 id="the-client-side-nightmare">The client-side nightmare</h3>
<p>There are endless sources of libraries, scripts, examples etc. online, but there are also dangers in relying on unstable technology. </p>
<p>Web technologies evolve at a remarkably fast rate. <a href="http://www.w3.org">Standards for web technologies are defined</a>, but are often only partially and sometimes incorrectly implemented by browser developers. Clients use a wide variety of platforms with different screen resolutions and capabilities, and different browsers, browser settings, plugins, and often quite old browser versions, making it very hard to predict what a page will look like or even whether it will even work. The situation today isn&#39;t much better than it was a decade ago (standards are clearer but vaster, and platforms are more diverse). Best practice is to keep things simple, detect failure and have fallback solutions, assume last year&#39;s technology at best, and test widely. </p>
<h3 id="jquery">JQuery</h3>
<p>To dynamically manipulated the DOM, we would normally have to do things like this:</p>
<pre><code><span class="hljs-regexp">//</span> Inserting a <span class="hljs-keyword">new</span> element after another <span class="hljs-reserved">with</span> the <span class="hljs-reserved">native</span> DOM API.
<span class="hljs-reserved">var</span> target = <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">"target"</span> );
<span class="hljs-reserved">var</span> newElement = <span class="hljs-built_in">document</span>.createElement( <span class="hljs-string">"div"</span> );
newElement.innerHTML = <span class="hljs-string">"&lt;b&gt;Hello World&lt;/b&gt;"</span>
target.parentNode.insertBefore( newElement, target.nextSibling );
</code></pre><p>Using jQuery, we can simply say:</p>
<pre><code><span class="hljs-keyword">var</span> newElement = $(<span class="hljs-string">"&lt;div&gt;&lt;/div&gt;"</span>);
newElement.html(<span class="hljs-string">"&lt;b&gt;Hello World&lt;/b&gt;"</span>);
$(<span class="hljs-string">"#target"</span>).after(newElement);
</code></pre><p><a href="http://jquery.com/">JQuery</a> helps navigate and control the DOM, for finding, manipulating and even generating the page. It also helps smooth over the differences between browsers.</p>
<h4 id="setup">Setup</h4>
<p>You can <a href="http://jquery.com/download/">download jquery</a> and link it to your page by adding this to the HTML header (make sure the src name matches the filename):</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"jquery-1.11.2.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre><p>Now you can access jquery from within your JavaScript code, using the <code>$</code> symbol. For example, to run code as soon as the document is ready to be manipulated, jQuery has a statement known as the ready event:</p>
<pre><code>$( <span class="hljs-built_in">document</span> ).ready(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-comment">// Your code here.</span>

});
</code></pre><p><a href="http://learn.jquery.com/about-jquery/how-jquery-works/">JQuery tutorial</a></p>
<p>If you are testing out ideas using <a href="http://jsfiddle.net/">JSFiddle</a>, you can select a JQuery library from the drop-down on the left.</p>
<h4 id="selectors">Selectors</h4>
<p>Most JQuery operations begin with a <strong>selector</strong>, which is a query into the DOM that returns one or more document elements. Examples: </p>
<pre><code>$()        <span class="hljs-comment">// the whole document</span>
$( <span class="hljs-string">"#myId"</span> );    
$( <span class="hljs-string">".myClass"</span> );
$( <span class="hljs-string">"#contents ul.people li"</span> );    <span class="hljs-comment">// complex CSS selector</span>
$( <span class="hljs-string">"a.external:first"</span> );    
$( <span class="hljs-string">"tr:odd"</span> );
$( <span class="hljs-string">"#myForm :input"</span> );    <span class="hljs-comment">// all form input nodes</span>
$( <span class="hljs-string">"div:visible"</span> );
$( <span class="hljs-string">"div:gt(2)"</span> ); <span class="hljs-comment">// all but first 3 divs</span>
$( <span class="hljs-string">"div:animated"</span> ); <span class="hljs-comment">// all animated divs</span>
</code></pre><p>Selections can be further refined with filters:</p>
<pre><code><span class="hljs-variable">$(</span> <span class="hljs-string">"div.foo"</span> ).has( <span class="hljs-string">"p"</span> );         <span class="hljs-comment">// div.foo elements that contain &lt;p&gt; tags</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"h1"</span> ).not( <span class="hljs-string">".bar"</span> );           <span class="hljs-comment">// h1 elements that don't have a class of bar</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"ul li"</span> ).<span class="hljs-keyword">filter</span>( <span class="hljs-string">".current"</span> ); <span class="hljs-comment">// unordered list items with class of current</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"ul li"</span> ).first();              <span class="hljs-comment">// just the first unordered list item</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"ul li"</span> ).eq( <span class="hljs-number">5</span> );              <span class="hljs-comment">// the sixth</span>
</code></pre><p>Ensure a selection is not empty:</p>
<pre><code><span class="hljs-keyword">if</span> ( $( <span class="hljs-string">"div.foo"</span> ).length ) {
    <span class="hljs-keyword">...</span>
}
</code></pre><p>Iterate a selection:</p>
<pre><code>$( <span class="hljs-string">"p"</span> ).each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(idx, element)</span> </span>{
    <span class="hljs-comment">// this points to the element:</span>
    <span class="hljs-built_in">console</span>.log( $( <span class="hljs-keyword">this</span> ).text() );
    <span class="hljs-comment">// do stuff</span>
}
</code></pre><p>With the selection you can set attributes:</p>
<pre><code>$( <span class="hljs-string">"h1"</span> ).html( <span class="hljs-string">"hello world"</span> );
$( <span class="hljs-string">"h1"</span> ).text( <span class="hljs-string">"hello world"</span> );    <span class="hljs-comment">// HTML will be stripped</span>

$( <span class="hljs-string">"h1"</span> ).addClass(<span class="hljs-string">"bold"</span>); <span class="hljs-comment">// and .removeClass()</span>
$( <span class="hljs-string">"h1"</span> ).css(<span class="hljs-string">"color"</span>, <span class="hljs-string">"red"</span>);
$( <span class="hljs-string">"h1"</span> ).css({
    color: <span class="hljs-string">"red"</span>, fontSize: <span class="hljs-number">100</span>px
);
<span class="hljs-comment">// also .width, .height, .position, etc.</span>

$( <span class="hljs-string">"a"</span> ).attr( <span class="hljs-string">"href"</span>, <span class="hljs-string">"allMyHrefsAreTheSameNow.html"</span> );
$( <span class="hljs-string">"a"</span> ).attr({
    title: <span class="hljs-string">"all titles are the same too!"</span>,
    href: <span class="hljs-string">"somethingNew.html"</span>
});
$( <span class="hljs-string">"a"</span> ).attr(<span class="hljs-string">"href"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(idx, href)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"somethingNew.html"</span>;
});
</code></pre><p>Usually the same function can also work as a getter (this is not the same as a query filter):</p>
<pre><code>$<span class="hljs-comment">( "a" )</span>.attr<span class="hljs-comment">( "href" )</span>; <span class="hljs-comment">// Returns the href for the first a element in the document</span>
</code></pre><p>Moving elements:</p>
<pre><code><span class="hljs-variable">$(</span> <span class="hljs-string">"#myList li:first"</span> ).appendTo( <span class="hljs-string">"#myList"</span> );
<span class="hljs-regexp">//</span> also .insert, insertTo, remove, detach, etc.
</code></pre><p>Adding elements:</p>
<pre><code><span class="hljs-keyword">var</span> myNewElement = $( <span class="hljs-string">"&lt;p&gt;New element&lt;/p&gt;"</span> );
myNewElement.appendTo( <span class="hljs-string">"<span class="hljs-subst">#content</span>"</span> );
$( <span class="hljs-string">"<span class="hljs-subst">#myList</span> li:first"</span> ).clone(<span class="hljs-literal">true</span>).appendTo( <span class="hljs-string">"<span class="hljs-subst">#myList</span>"</span> );
 myNewElement.appendTo( <span class="hljs-string">"<span class="hljs-subst">#content</span>"</span> );
</code></pre><p>Get parent(s), children and siblings of a selection:</p>
<pre><code>   <span class="hljs-function"> $(</span><span class="hljs-string">"#foo"</span><span class="hljs-function">)</span>.parent(<span class="hljs-function">)</span>;    //<span class="hljs-instruction"> array </span>of one item
   <span class="hljs-function"> $(</span><span class="hljs-string">"#foo"</span><span class="hljs-function">)</span>.parents(<span class="hljs-function">)</span>;    //<span class="hljs-instruction"> array </span>of all parents
   <span class="hljs-function"> $(</span><span class="hljs-string">"#foo"</span><span class="hljs-function">)</span>.closest(<span class="hljs-string">"div"</span><span class="hljs-function">)</span>;    // first ancestor that is a<span class="hljs-instruction"> div
</span>
   <span class="hljs-function"> $(</span><span class="hljs-string">"#foo"</span><span class="hljs-function">)</span>.children(<span class="hljs-string">"div"</span><span class="hljs-function">)</span>;    //<span class="hljs-instruction"> array </span>of all immediate<span class="hljs-instruction"> div </span>children
   <span class="hljs-function"> $(</span><span class="hljs-string">"#foo"</span><span class="hljs-function">)</span>.find(<span class="hljs-string">"div"</span><span class="hljs-function">)</span>;    //<span class="hljs-instruction"> array </span>of all immediate<span class="hljs-instruction"> and </span>nested<span class="hljs-instruction"> div </span>children

    // also .next, .prev, .nextAll, .prevAll, .siblings
</code></pre><h4 id="events">Events</h4>
<p>Without jQuery, we can add events to HTML like so:</p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"alert('Hello')"</span>&gt;</span>Say hello<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
</code></pre><p>But this quickly becomes tiresome, and isn&#39;t dynamic. jQuery provides <a href="http://api.jquery.com/category/events/">simple methods for attaching event handlers</a> to selections. When an event occurs, the provided function is executed. Inside the function, this refers to the element that was clicked.</p>
<pre><code><span class="hljs-comment">// Event setup using a convenience method</span>
$( <span class="hljs-string">"p"</span> ).click(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"You clicked a paragraph!"</span> );
});

<span class="hljs-comment">// Equivalent event setup using the `.on()` method</span>
$( <span class="hljs-string">"p"</span> ).on( <span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"click"</span> );
});

<span class="hljs-comment">// Binding multiple events with different handlers</span>
$( <span class="hljs-string">"p"</span> ).on({
    <span class="hljs-string">"click"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"clicked!"</span> ); },
    <span class="hljs-string">"mouseover"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"hovered!"</span> ); }
});

<span class="hljs-comment">// Tearing down all click handlers on a selection</span>
$( <span class="hljs-string">"p"</span> ).off( <span class="hljs-string">"click"</span> );
</code></pre><p>Every event handling function receives an event object, which contains many properties and methods. The event object is most commonly used to prevent the default action of the event via the .preventDefault() method. However, the event object contains a number of other useful properties and methods, including: <code>pageX, pageY, type, which, target, timeStamp</code>. The event handling function also has access to the DOM element that the handler was bound to via the keyword this, which we can turn into jQuery object:</p>
<pre><code><span class="hljs-keyword">var</span> element = $( <span class="hljs-keyword">this</span> );
</code></pre><p>You can stop the default action and event bubbling like this:</p>
<pre><code><span class="hljs-comment">// Prevent the form's default submission.</span>
<span class="hljs-keyword">event</span>.preventDefault();

<span class="hljs-comment">// Prevent event from bubbling up DOM tree, prohibiting delegation</span>
<span class="hljs-keyword">event</span>.stopPropagation();
</code></pre><h4 id="utilities-">Utilities:</h4>
<pre><code><span class="hljs-variable">$.</span><span class="hljs-keyword">trim</span>(str); <span class="hljs-comment">// remove whitespace padding from string</span>
<span class="hljs-variable">$.</span>each(list, func(key, val))
</code></pre><h4 id="effects">Effects</h4>
<pre><code><span class="hljs-comment">// Instantaneously hide all paragraphs</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"p"</span> ).<span class="hljs-keyword">hide</span>();
<span class="hljs-comment">// Instantaneously show all divs that have the hidden style class</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"div.hidden"</span> ).show();
<span class="hljs-comment">// Slowly hide all paragraphs</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"p"</span> ).<span class="hljs-keyword">hide</span>( <span class="hljs-string">"slow"</span> );
<span class="hljs-comment">// Quickly show all divs that have the hidden style class</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"div.hidden"</span> ).show( <span class="hljs-string">"fast"</span> );
<span class="hljs-comment">// Hide all paragraphs over half a second</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"p"</span> ).<span class="hljs-keyword">hide</span>( <span class="hljs-number">500</span> );
<span class="hljs-comment">// Show all divs that have the hidden style class over 1.25 seconds</span>
<span class="hljs-variable">$(</span> <span class="hljs-string">"div.hidden"</span> ).show( <span class="hljs-number">1250</span> );
</code></pre><p>Custom animations:</p>
<pre><code><span class="hljs-comment">// Custom effects with .animate()</span>
$( <span class="hljs-string">"div.funtimes"</span> ).animate(
    {
        left: <span class="hljs-string">"+=50"</span>,
        opacity: <span class="hljs-number">0.25</span>
    },

    <span class="hljs-comment">// Duration</span>
    <span class="hljs-number">300</span>,

    <span class="hljs-comment">// Callback to invoke when the animation is finished</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">console</span>.log( <span class="hljs-string">"done!"</span> );
    }
);
</code></pre><p><a href="http://learn.jquery.com/effects/intro-to-effects/">More about effects here</a></p>
<h4 id="ajax">Ajax</h4>
<p><a href="http://learn.jquery.com/ajax/key-concepts/">See tutorial</a></p>
<pre><code>$.get( <span class="hljs-string">"foo.php"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( response )</span> </span>{
    <span class="hljs-built_in">console</span>.log( response ); <span class="hljs-comment">// server response</span>
});
</code></pre><p>In general, Ajax requests are limited to the same protocol (http or https), the same port, and the same domain as the page making the request. This limitation does not apply to scripts that are loaded via <a href="http://learn.jquery.com/ajax/jquery-ajax-methods/">jQuery&#39;s Ajax methods</a>.</p>
<p>For JSONP, <a href="http://learn.jquery.com/ajax/working-with-jsonp/">see tutorial</a></p>
<h3 id="visualization">Visualization</h3>
<ul>
<li><a href="http://d3js.org">D3.js</a> is a JavaScript library for manipulating documents based on data.<br><a href="http://chimera.labs.oreilly.com/books/1230000000345/index.html"><img src="http://alignedleft.com/assets/images/idvftw_cover.gif" alt="Interactive Data Visualization for the Web, Scott Murray"></a></li>
<li><a href="https://developers.google.com/chart/interactive/docs/reference">The Google Visualization API</a></li>
<li><a href="http://sigmajs.org">Sigma graph drawing</a></li>
</ul>
<h2 id="server-side-programming">Server-side programming</h2>
<p>Sites can be <strong>static</strong> or <strong>dynamic</strong>. A dynamic site generates files in response to requests from a client. A static site just returns pre-existing files. Note that static files can still embed JavaScript for dynamic content generated or accessed from the client. </p>
<p>HTML is human-readable, but not very pleasantly so; and writing it by hand is laborious, error-prone and inefficient. Since page content is often repetitive, most sites are generated by combining database records or document-based stores with modular templates. A fully dynamic site generates the pages as needed, however there is also an increasing interest in <strong>static site generators</strong>: programs that convert simple human-readable text (such as markdown) into full HTML static sites, which can then be published. After all, most of the essentially dynamic parts (page stats, comments, twitter/facebook integration, etc.) can be provided by embedding external cloud services on the client-side. Two easy and free ways to serve static sites are Dropbox public folders and Github pages. </p>
<h3 id="the-server-side-nightmare">The server-side nightmare</h3>
<p>Performance, bandwidth, backup, security, DoS etc. </p>
<h2 id="xmlhttprequest">XMLHttpRequest</h2>
<blockquote>
<p>XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It&#39;s now being standardized in the W3C. It provides an easy way to retrieve data from a URL without having to do a full page refresh. </p>
</blockquote>
<p>The XMLHttpRequest object is available both in <a href="https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest">client browser JavaScript</a>, and in Max/MSP/Jitter JavaScript (with some small differences -- see the maxurl help file). </p>
<p>A typical example looks like this:</p>
<pre><code class="lang-javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reqListener</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.responseText);    <span class="hljs-comment">// Browser</span>
        <span class="hljs-comment">//post(this.responseText);        // Max</span>
    }

    <span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();
    req.onreadystatechange = reqListener;
    req.open(<span class="hljs-string">"get"</span>, <span class="hljs-string">"http://api.openweathermap.org/data/2.5/weather?q=Toronto,ca&amp;units=metric"</span>, <span class="hljs-literal">true</span>);
    req.setRequestHeader(<span class="hljs-string">"Content-Type"</span> , <span class="hljs-string">"application/json"</span>);
    req.send();
</code></pre>
<p>In the browser, we can also use jQuery&#39;s <code>$.get</code> wrapper for XMLHttpRequest. See <a href="http://api.jquery.com/jquery.get/">manual</a>.</p>
<pre><code>// <span class="hljs-operator"><span class="hljs-keyword">insert</span> snippet.html <span class="hljs-keyword">into</span> the page <span class="hljs-keyword">at</span> the <span class="hljs-keyword">div</span> named <span class="hljs-string">"result"</span>:
$.<span class="hljs-keyword">get</span>( <span class="hljs-string">"snippet.html"</span>, <span class="hljs-keyword">function</span>( <span class="hljs-keyword">data</span> ) {
  $( <span class="hljs-string">"#result"</span> ).html( <span class="hljs-keyword">data</span> );</span>
  alert( "<span class="hljs-operator"><span class="hljs-keyword">Load</span> was performed.<span class="hljs-string">" );
});</span></span>
</code></pre><h3 id="cross-origin-resource-sharing-cors-">Cross-Origin Resource Sharing (CORS)</h3>
<p>For security, browsers typically do not allow a website on one domain to dynamically pull in data from another domain; i.e. they typically apply a <em>same-domain policy</em>. Fortunately, in the case of XMLHttpRequests, the provider may explicitly allow CORS, as is the case for <a href="http://api.openweathermap.org">http://api.openweathermap.org</a>. Moreover, most dynamic requests will fail when running the HTML file from a local filesystem. <em>They need to be running from a server.</em> </p>
<p>Node.js lets us write complex server applications, but it also provides a simple way to run a server from any location on your filesystem. First, install this capability on your computer by typing this in your terminal (you&#39;ll have to make sure node.js is installed first of course, see above):</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> -g http-<span class="hljs-keyword">server</span></span>
</code></pre><p>Once installed, you can run this from any location in your terminal like this:</p>
<pre><code>http-<span class="hljs-keyword">server</span>
</code></pre><p>And you can then open this in your browser at address <a href="http://0.0.0.0:8080/test.html">http://0.0.0.0:8080/test.html</a></p>
<h3 id="handling-the-response-in-max-">Handling the response in Max:</h3>
<p>If the response is JSON formatted, we can convert this into a regular JavaScript object:</p>
<pre><code><span class="hljs-comment">// convert JSON response into a javascript object:</span>

var <span class="hljs-keyword">body</span> = JSON.parse(<span class="hljs-keyword">this</span>.responseText);

post(<span class="hljs-keyword">body</span>);
</code></pre><p>Alternatively, in Max we could copy it into an existing [dict] object, so long as the names match:</p>
<pre><code><span class="hljs-comment">// copy JSON response into a dict:</span>
<span class="hljs-keyword">var</span> <span class="hljs-keyword">d</span> = new Dict(<span class="hljs-string">"mydict"</span>);        <span class="hljs-comment">// assumes the Max patch has a [dict mydict] object</span>
<span class="hljs-keyword">d</span>.<span class="hljs-keyword">parse</span>(this.responseText);
</code></pre><h3 id="handling-the-response-in-a-browser-">Handling the response in a browser:</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">See the MDN tutorial</a></p>

	</div>
	<footer>
		&copy; 2015 Graham Wakefield
	</footer>
  </body>
</html>