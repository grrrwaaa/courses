<!DOCTYPE html>
<html>
  <head>
	<title>js</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" href="github.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="README.html" alt="README">README</a></li>
<li><a href="assignments.html" alt="assignments">assignments</a></li>
<li><a href="index.html" alt="index">index</a></li>
<li><a href="database.html" alt="database">database</a></li>
<li><a href="js.html" alt="js">js</a></li>
<li><a href="opendata.html" alt="opendata">opendata</a></li>
<li><a href="software.html" alt="software">software</a></li>
	</ul></nav>	
	<div id="main">
	<h1 id="javascript-quickly">JavaScript, quickly</h1>
<p><a href="http://en.wikipedia.org/wiki/JavaScript">JavaScript</a> (JS) is a language of growing importance at the intersection of media/culture technology:</p>
<ul>
<li>It has become the de facto &#39;language of the web&#39; (following the failure of Java applets and resistance to plugins such as Flash), having evolved from lightweight scripting roots to a full-fledged application language with powerful capabilities in HTML5. </li>
<li>Not only is it used pervasively in client browser-based applications, it is also used for high-performance server applications, particularly using the <a href="http://nodejs.org/">node.js</a> system. </li>
<li>JS has also been used as an embedded scripting language for desktop applications by Google, Adobe, OpenOffice, Apple, MicroSoft, Qt, GNOME, etc., including many media-oriented applications such as Max/MSP/Jitter, <a href="http://en.wikipedia.org/wiki/Processing.js">Processing</a>, Logic Pro, Unity, DX Studio, Maxwell Render, Flash, etc., and many games/game engines.</li>
</ul>
<p><strong>Note: Despite the similarity of name, JavaScript has no particular relation to Java.</strong> JavaScript is however also known as <a href="http://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a>, JScript, and ActionScript.</p>
<h3 id="for-media-culture-technology-purposes-">For media/culture technology purposes:</h3>
<ul>
<li>A browser-based JS application will run on Windows, OSX, Linux, Android, iOS etc., so long as browser applications are up to date. In recent years this has meant that even low-level audio signal processing and 3D OpenGL are available for use. </li>
<li>Browser and server-based applications open up easy possibilities to reach out to vast audiences and connect to social and other media networks, to explore collaborative interfaces, to interact with the increasing number of devices supporting HTTP and WebSocket APIs, etc.</li>
<li>Examples:<ul>
<li><a href="http://gibber.mat.ucsb.edu/">Live coding audio (and graphics)</a></li>
<li><a href="https://www.shadertoy.com/">Shadertoy</a></li>
<li><a href="http://aleksandarrodic.com/p/jellyfish/">Jellyfish</a> and <a href="http://webglsamples.org/fishtank/fishtank.html">Fish</a> and <a href="http://empaempa.github.io/GLOW/examples/complicated/">Horses</a> and <a href="http://alteredqualia.com/three/examples/webgl_cars.html">Cars</a> and <a href="http://cake23.de/turing-fluid.html">Reaction Diffusion</a></li>
<li><a href="http://globe.chromeexperiments.com/">World population globe</a>; the globe itself is <a href="http://www.chromeexperiments.com/globe">open source</a></li>
</ul>
</li>
</ul>
<p>Nevertheless, JavaScript is not the greatest language, and incorporates some rather poor designs; we&#39;ll work through and around those as we go.</p>
<p>ECMAScript 5 is a reduced and modified set of JavaScript that aims to remove some of the bad parts. You might be able to use ES5 in modern browsers, by placing <code>&quot;use strict&quot;</code> at the head of each function:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
<span class="hljs-pi">    "use strict"</span>;
    <span class="hljs-comment">// all your ES5 script here:</span>
    <span class="hljs-comment">// ...</span>
}
</code></pre><h3 id="flexible-fast-well-supported-">Flexible, fast, well-supported:</h3>
<ul>
<li><p>JS is a primarily imperative, procedural language (just like C, Java, Python, etc.), however it also supports functional programming features such as first-class functions. It has been described as Lisp in C&#39;s clothing. It is dynamically-typed and object-based, but uses a more flexible, dynamic <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based</a> rather than static class-based inheritance. </p>
</li>
<li><p>Although it is a dynamic language, JS virtual machines such as <a href="http://en.wikipedia.org/wiki/V8_(JavaScript_engine">Google&#39;s V8</a>) can achieve remarkably high performance through implicit Just-In-Time compilation to machine code.  </p>
</li>
<li><p>The JS community is vast, and the available libraries, modules, frameworks, extensions, etc. are correspondingly huge. For example <a href="https://www.npmjs.org/">npm</a> lists over 100,000 (at time of writing) libraries for node.js desktop/server-side applications. </p>
</li>
<li><p>JS has become the language of choice for several Introduction to Computer Science (CS101) courses, including at <a href="http://www.stanford.edu/class/cs101/">Stanford University</a> (also <a href="https://www.coursera.org/course/cs101">here</a>). The Khan Academy also offers <a href="https://www.khanacademy.org/cs">a free, online course</a>.</p>
</li>
</ul>
<h2 id="additional-learning-resources-">Additional learning resources:</h2>
<ul>
<li><a href="http://eloquentjavascript.net">Eloquent JavaScript</a></li>
<li><a href="http://www.w3schools.com/js/">W3C JavaScript Guide</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide">Mozilla JavaScript Guide</a></li>
<li><a href="http://www.codecademy.com/tracks/javascript">Codecadamy</a></li>
<li><a href="https://www.khanacademy.org/cs/programming">Khan Academy</a></li>
<li><a href="https://www.coursera.org/course/cs101">Stanford CS101</a></li>
<li><a href="http://www.nodebeginner.org/">The Node handbook</a></li>
<li><a href="http://howtonode.org/">How to Node</a></li>
<li><a href="http://wtfjs.com/">WTFJS</a></li>
<li>JavaScript: The Good Parts, Douglas Crockford, O&#39;Reilly</li>
</ul>
<h2 id="brief-overview-of-the-language">Brief overview of the language</h2>
<h3 id="tl-dr-">TL;DR:</h3>
<ul>
<li><strong>The best parts</strong><ul>
<li>Functions are first-class objects<ul>
<li>anonymous functions, functions as properties, arguments, return values; closures, callbacks, currying etc.</li>
</ul>
</li>
<li>Dynamic objects with prototypal inheritance<ul>
<li>No limitation to pre-defined types and classes</li>
</ul>
</li>
<li>Object and array literals<ul>
<li>Convenient notation that became JSON</li>
</ul>
</li>
</ul>
</li>
<li><strong>The worst parts</strong><ul>
<li>JavaScript tries to make things easier for you, which eventually makes you confused.</li>
<li>Variables are global by default<ul>
<li>Any variable defined outside a function (with <code>var</code> or without), </li>
<li>any inside a function without using <code>var</code></li>
</ul>
</li>
<li>Calling a constructor without <code>new</code> will bind <code>this</code> to the global object and throw no errors<ul>
<li>Capitalize constructors to help you notice these bugs, or</li>
<li>Build objects without using <code>new</code> and constructors.</li>
</ul>
</li>
<li>Scope is function-level, not block-level. <ul>
<li>Variables declared in a block are visible throughout the function. Declare all variables at the function start. </li>
</ul>
</li>
<li><code>typeof null</code> -&gt; object, <code>typeof array</code> -&gt; object</li>
<li>Too many falsy values, and falsiness used to widely.<ul>
<li><code>false, 0, NaN, &#39;&#39;, null, undefined</code> are falsy</li>
<li>Missing values are <code>undefined</code>, not <code>null</code>. </li>
<li>Use <code>===</code> and <code>!==</code>, not <code>==</code> and <code>!=</code>.  </li>
</ul>
</li>
<li>Iterating objects will pick up properties and methods from the prototype chain. <ul>
<li>Use <code>.hasOwnProperty()</code>.</li>
</ul>
</li>
<li>Optional syntax means that mistakes are often not found by the parser<ul>
<li>Always put semicolons, always wrap blocks in { }. </li>
</ul>
</li>
<li>There are lots of bad syntax possibilities and bad library functions in JavaScript that you will find in production code and online tutorials. Don&#39;t trust what you find.</li>
<li>Regular expressions are hard to read and write, causing many bugs (and security vulnerabilities!)</li>
</ul>
</li>
</ul>
<h3 id="types">Types</h3>
<p>JavaScript types are: number, string, true, false, null, undefined, and object. Numbers and strings are object-like in having methods, but they are immutable. Arrays, functions, regular expressions are objects. </p>
<p><code>typeof n</code> returns the type of variable <code>n</code> as a string, which may be: <code>number, string, boolean, undefined, function, object</code>; however if the operand is an array, or null, it will also return <code>object</code>. </p>
<h3 id="strings">Strings</h3>
<p>Strings are bounded by <code>&quot;</code> or <code>&#39;</code>. Characters are 16-bit. Special characters are escaped: <code>\&quot;, \&#39;, \\, \/, \n (newline), \t (tab)</code>. Also character codes, e.g. <code>&quot;A&quot; === &quot;\u0041&quot;</code>.</p>
<p>Strings are immutable but can be concatenated with <code>+</code> and manipulated through methods.</p>
<pre><code><span class="hljs-string">"seven"</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">5</span>
<span class="hljs-string">'cat'</span>.toUpperCase() === <span class="hljs-string">'CAT'</span>
</code></pre><p><code>string.charAt(n)</code> returns the character (a string of length 1) at position n. <code>string.charCodeAt(n)</code> returns a character code (integer). <code>string.fromCharCode(n)</code> converts back to a string.</p>
<p><code>string.indexOf(s, i)</code> returns the first index of s, starting at position i. If not found, it returns -1. See also <code>string.lastIndexOf</code>.</p>
<p><code>string.slice(start, end)</code> makes a copy of a subsection of the string. Indices can be negative.</p>
<p><code>string.split(separator, limit)</code> creates an array of strings according to a separator (which can be &#39;&#39;). Limit is optional. </p>
<h3 id="numbers">Numbers</h3>
<p>There is no integer type, all numbers are floats. <code>10</code> is the same as <code>10.0</code> is the same as <code>1e1</code>. Convert a float to an integer using <code>Math.floor(), Math.ceil()</code> etc. </p>
<p>All kinds of unexpected fun can happen from the fact that floats cannot accurately represent many numbers. This can be surprising, e.g. <code>0.1 + 0.2 === 0.3</code> returns false. See <a href="http://wtfjs.com/">wtfjs</a> for more examples.</p>
<p><code>1/0</code> returns <code>Infinity</code>. </p>
<p><code>Math.sqrt(-1)</code> and similar return <code>NaN</code>. You can check with <code>isNaN(number)</code>. Note that <code>NaN</code> is not equal to itself.</p>
<p>To check if a value is a usable number:</p>
<pre><code><span class="hljs-keyword">var</span> isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> v === <span class="hljs-string">"number"</span> &amp;&amp; <span class="hljs-built_in">isFinite</span>(v);
}
</code></pre><p>There are several built-in numbers (constants) such as <code>Math.PI</code>.</p>
<p>Numbers have several methods for conversion to string, such as <code>number.toString()</code>, <code>number.toFixed(n)</code>, <code>number.toPrecision(n)</code> etc.</p>
<h3 id="booleans-truthiness">Booleans &amp; truthiness</h3>
<p><code>true</code> and <code>false</code> are the only boolean values, but in most cases JavaScript uses a more permissive sense of truthiness/falsyness, because of automatic type coercion.</p>
<p><em>falsy</em> values are <code>false, null, undefined, &#39;&#39;, 0, NaN</code>; all other values are <em>truthy</em>. An <code>if</code> condition (and similarly <code>case, while, for</code>) will test for truthiness, not truth. The <code>!</code> unary operator uses truthiness (not truth), and the boolean operators <code>&amp;&amp;, ||</code> also use truthiness. </p>
<p>To explicitly use truth (not truthiness), use the <code>===</code> comparators.</p>
<h3 id="control-flow">Control flow</h3>
<p>The common forms:</p>
<pre><code><span class="hljs-keyword">if</span> (&lt;cond&gt;) {
    <span class="hljs-comment">// "then" clause</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (&lt;cond2&gt;) {
    <span class="hljs-comment">// alternate then</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// all other cases</span>
}

<span class="hljs-keyword">for</span> (&lt;<span class="hljs-keyword">init</span>&gt;; &lt;cond&gt;; &lt;increment&gt;) {
    <span class="hljs-comment">// body</span>
}

<span class="hljs-comment">// note: the order is unpredictable.</span>
<span class="hljs-keyword">for</span> (&lt;name&gt; <span class="hljs-keyword">in</span> &lt;obj&gt;) {
    <span class="hljs-comment">// body</span>
}

<span class="hljs-keyword">while</span> (&lt;expr&gt;) {
    <span class="hljs-comment">// until expr is falsy</span>
}
</code></pre><h3 id="objects">Objects</h3>
<p>An object maps keys (strings, including &#39;&#39;) to values (anything at all except <code>undefined</code>). A key only appears once. Objects collect &amp; organize data. Keys can be added, modified and removed.</p>
<pre><code><span class="hljs-keyword">var</span> emptyobj = {};
<span class="hljs-keyword">var</span> binarytree = {
    <span class="hljs-string">"left"</span>: {            <span class="hljs-comment">// note: quotes around keys are optional</span>
        <span class="hljs-string">"left"</span>: <span class="hljs-number">10</span>,        <span class="hljs-comment">// so long as key name is valid syntax</span>
        <span class="hljs-string">"right"</span>: <span class="hljs-number">20</span>        <span class="hljs-comment">// for a JavaScript variable name</span>
    },
    <span class="hljs-string">"right"</span>: {
        <span class="hljs-string">"left"</span>: <span class="hljs-number">5</span>,
        <span class="hljs-string">"right"</span>: <span class="hljs-number">13</span>
    }
}

<span class="hljs-comment">// indexing objects:</span>
binarytree[<span class="hljs-string">"left"</span>][<span class="hljs-string">"left"</span>];     <span class="hljs-comment">// 10</span>
binarytree.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">left</span>;     <span class="hljs-comment">// 10</span>
binarytree.middle;        <span class="hljs-comment">// undefined</span>
binarytree.middle || <span class="hljs-number">7</span>;    <span class="hljs-comment">// 7</span>
binarytree.middle.middle;    <span class="hljs-comment">// throw TypeError</span>
binarytree.middle &amp;&amp; binarytree.middle.middle;    <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// Warning: indexing will also check methods and prototypes:</span>
binarytree.<span class="hljs-built_in">toString</span>;    <span class="hljs-comment">// returns a function</span>

<span class="hljs-comment">// adding &amp; removing keys:</span>
emptyobj.x = <span class="hljs-number">10</span>;
emptyobj.x;    <span class="hljs-comment">// 10</span>
delete emptyobj.x;
emptyobj.x;    <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// objects are passed by reference (i.e. they are not copied):</span>
z = binarytree.<span class="hljs-keyword">left</span>;
z.<span class="hljs-keyword">right</span> = <span class="hljs-number">999</span>;
binarytree.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">right</span>;    <span class="hljs-comment">// 999</span>
</code></pre><h3 id="arrays">Arrays</h3>
<p>JavaScript arrays are not linear allocations of memory (as in C), but objects with an array-like interface. Like objects, array values need not be the same type. Values can be of any type.</p>
<pre><code>var emptyarray = [];
var myarray = [
    <span class="hljs-string">"zero"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>
];
emptyarray[<span class="hljs-number">1</span>];         <span class="hljs-regexp">//</span> undefined
myarray[<span class="hljs-string">"1"</span>];         <span class="hljs-regexp">//</span> <span class="hljs-string">"one"</span>
myarray[<span class="hljs-number">1</span>];         <span class="hljs-regexp">//</span> <span class="hljs-string">"one"</span>
emptyarray.<span class="hljs-keyword">length</span>;    <span class="hljs-regexp">//</span> <span class="hljs-number">0</span>
myarray.<span class="hljs-keyword">length</span>;        <span class="hljs-regexp">//</span> <span class="hljs-number">5</span>

<span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span>; i &lt; myarray.<span class="hljs-keyword">length</span>; i++) {
    console.<span class="hljs-keyword">log</span>(i, myarray[i]);
}

// grow:
myarray[myarray.<span class="hljs-keyword">length</span>] = <span class="hljs-string">"five"</span>;
myarray.<span class="hljs-keyword">push</span>(<span class="hljs-string">"six"</span>);     <span class="hljs-regexp">//</span> myarray is now: 
<span class="hljs-regexp">//</span> [<span class="hljs-string">"zero"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>, <span class="hljs-string">"six"</span>]
myarray.<span class="hljs-keyword">length</span>;        <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>

// shrink:
myarray.<span class="hljs-keyword">pop</span>();    <span class="hljs-regexp">//</span> returns <span class="hljs-string">"six"</span>, myarray is now:
<span class="hljs-regexp">//</span> [<span class="hljs-string">"zero"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>
myarray.<span class="hljs-keyword">length</span> = <span class="hljs-number">3</span>;
<span class="hljs-regexp">//</span> myarray is now [<span class="hljs-string">"zero"</span>, <span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>]

// .<span class="hljs-keyword">length</span> is <span class="hljs-keyword">not</span> necessarily to be trusted:
emptyarray[<span class="hljs-number">1000</span>] = <span class="hljs-number">1</span>;    
emptyarray.<span class="hljs-keyword">length</span>;    <span class="hljs-regexp">//</span> <span class="hljs-number">1001</span>
</code></pre><p>Because arrays are really objects, we can add non-numeric properties and methods to individual arrays. We can also change their <code>.prototype</code>. Arrays inherit from <code>Array.prototype</code> by default, which gives them many useful methods (and the <code>.length</code> special property). </p>
<p>Don&#39;t use <code>delete</code> on arrays; it will leave <code>undefined</code> holes in them. Instead use <code>.splice(index, elements_to_remove, elements_to_add)</code>:</p>
<pre><code>[<span class="hljs-string">"a"</span>, <span class="hljs-string">"p"</span>, <span class="hljs-string">"q"</span>, <span class="hljs-string">"c"</span>].splice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>);    <span class="hljs-regexp">//</span> [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>]
</code></pre><p><code>array.concat(items...)</code> will create a new array (a shallow copy) and push items onto the end. <code>array.slice(start, end)</code> will create a shallow copy from a sub-section of the array. Do not confuse <code>slice</code> with <code>splice</code>.</p>
<p><code>array.join(separator)</code> will turn the array into a string.</p>
<p><code>array.shift()</code> removes and returns the first element, <code>array.pop()</code> removes and returns the last element. <code>array.unshift(item)</code> prepends to the start of the array, <code>array.push(item)</code> appends to the end. </p>
<p><code>array.sort(comparefunc)</code>. The default comparefunc is alphabetic, so it will sort numbers incorrectly. Provide your own comparefunc, which takes two arguments and returns negative if the first item is lower, positive if the second item is lower, and zero if they are equal. E.g.:</p>
<pre><code><span class="hljs-comment">// sort numbers properly:</span>
<span class="hljs-keyword">array</span>.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{ <span class="hljs-keyword">return</span> a - b; });
</code></pre><p>Multidimensional arrays are just arrays whose values are arrays. E.g. to create a 3x3 array of zeroes:</p>
<pre><code><span class="hljs-keyword">var</span> z = [
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
];
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">var</span> z = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r=<span class="hljs-number">0</span>; r&lt;<span class="hljs-number">3</span>; r++) {
    z[r] = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-built_in">c</span>=<span class="hljs-number">0</span>; <span class="hljs-built_in">c</span>&lt;<span class="hljs-number">3</span>; <span class="hljs-built_in">c</span>++) {
        z[r][<span class="hljs-built_in">c</span>] = <span class="hljs-number">0</span>;
    }
}
</code></pre><p>Note: since <code>typeof myarray</code> returns <code>&quot;object&quot;</code>, we must use the prototype to distinguish objects &amp; arrays:</p>
<pre><code><span class="hljs-keyword">var</span> is_array = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> </span>{
    <span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">"object"</span> &amp;&amp; obj.constructor === <span class="hljs-built_in">Array</span>;
}
</code></pre><h3 id="functions">Functions</h3>
<ul>
<li>Functions are <em>first-class</em> objects</li>
<li>Functions provide scope</li>
</ul>
<p>Functions are objects; they can have properties. Functions also store their context. As objects, they can be stored in variables, objects, arrays etc, and passed around as arguments &amp; return values of other functions. For example, passing a function as an argument is commonly done when specifying callbacks. </p>
<p>If a function is a property of another object, it is called a <strong>method</strong>. Functions themselves can also have methods.</p>
<pre><code><span class="hljs-keyword">var</span> &lt;name&gt; = <span class="hljs-function"><span class="hljs-keyword">function</span> &lt;<span class="hljs-title">optional</span> <span class="hljs-title">name</span>&gt;<span class="hljs-params">(&lt;argument list&gt;)</span> </span>{
    &lt;body&gt;
}

<span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> </span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>Note that functions are <em>hoisted</em> to the top of the program; that means functions don&#39;t have to be declared in order that they are used. You can use a function that is declared later in the program.</p>
<p>A function can be invoked with more or less values than specified in its definition. Extra arguments are ignored, missing arguments are <code>undefined</code>. When invoked, functions also receive hidden variables <code>this</code> and <code>arguments</code>.  </p>
<p><code>arguments</code> is an array-like object of all the arguments passed to the function, including excess arguments. It is not really an array, and only has the .length property and support for <code>[]</code> indexing. It is there to allow functions with variable numbers of arguments:</p>
<pre><code>var sum = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    var <span class="hljs-built_in">i</span>, sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>; <span class="hljs-built_in">i</span>&lt;arguments.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{
        sum += arguments[i];
    }</span>
    <span class="hljs-keyword">return</span> sum;
}
</code></pre><p>What <code>this</code> refers to depends on how the function was invoked:</p>
<ul>
<li>as a method: <code>this</code> refers to the object invoking its method.</li>
<li>as a constructor (using <code>new</code>): <code>this</code> refers to the new object being created.</li>
<li>via function<code>.apply()</code>: <code>this</code> is the first argument of apply (the second argument is a list of arguments passed to the function)</li>
<li>via function<code>.call()</code>: <code>this</code> is the first argument of call (the remaining arguments are passed to the function)</li>
<li>as a function: <code>this</code> refers to the global object. <strong>This is a major cause of bugs!</strong> In particular, calling a constructor without using <code>new</code> is a common mistake that leads to a terrible mess.</li>
</ul>
<p>Functions can be defined anywhere an expression can appear, even inside other functions (in which case they can access private variables of the outer function). However, because of the way <code>this</code> is defined, inner functions do not inherit <code>this</code> from the outer function. The usual workaround is as follows:</p>
<pre><code>myobj.outer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;    <span class="hljs-comment">// make a local reference</span>
    <span class="hljs-keyword">var</span> inner = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// can't use "this" here, as it would refer to the global object</span>
        that.value = that.value + that.value;
    }

    inner();
}
</code></pre><p>If you can understand this, then you have mastered one half of JavaScript&#39;s complexity. </p>
<p>By default functions link to <code>Function.prototype</code>. Functions <strong>also</strong> have a <code>.prototype</code> property; do not confuse these two! A function&#39;s <code>.prototype</code> is an object whose <code>.constructor</code> is the function itself. </p>
<h4 id="scope">Scope</h4>
<p><strong>JavaScript has function scope, not block scope.</strong> Within a function, the <code>var</code> statement defines the function&#39;s private variables. Best practice is to always declare these at the top of the function, since this is their scope (<code>if</code>, <code>for</code> and other blocks do not create new scopes). Forgetting this can easily lead to bugs.</p>
<p>Nested inner functions can access and modify variables defined their outer function scope -- even if the inner function has a longer lifetime (by being returned). Note that these are references, not copies. </p>
<p>However, if the inner function declares a variable with <code>var</code>, this is local to the inner function and will mask a same-named variable in the outer function scope. Note that the <code>this</code> and <code>arguments</code> of the outer scope are NOT visible in the inner scope.</p>
<p>Outside of functions, variables are always global. This can rapidly lead to bugs, so either put your variables inside of objects or wrap them in functions. Note, in the browser the global object is called <code>window</code>.</p>
<p>In particular, we want to carefully chose what is exposed and what is hidden when creating <strong>modules</strong>. Modules are like libraries: re-usable code with a well-defined interface. A module should not modify any global variables or otherwise conflict with other modules. Module definitions are typically defined within a function that is immediately invoked to return the actual module itself.</p>
<pre><code><span class="hljs-keyword">var</span> &lt;modulename&gt; = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> m = {};
    <span class="hljs-comment">// populate m with the module's interface</span>
    <span class="hljs-comment">// any helper methods are defined with var to ensure they remain private</span>
    <span class="hljs-comment">// avoid use of "this"</span>
    <span class="hljs-keyword">return</span> m;
}();
</code></pre><h3 id="inheritance">Inheritance</h3>
<p>There are no classes, but each object links to a &quot;prototype&quot; from which properties can be inherited. By default, objects link to <code>Object.prototype</code>. </p>
<p>The prototype is used when we index a key that the object doesn&#39;t contain; in that case, it automatically tries to index the prototype; and so on until we reach Object.prototype, in which case we return undefined. This is <em>delegation</em>. </p>
<p>Use <code>obj.hasOwnProperty(key)</code> to bypass the prototype chain.</p>
<p>Unlike classes, prototypes can be dynamically modified.</p>
<p>The way to write this in JavaScript is messy. When a function is invoked with <code>new</code>, a new object is created with a link to the function&#39;s <code>.prototype</code> property. </p>
<pre><code><span class="hljs-comment">// define a function to be a constructor</span>
<span class="hljs-comment">// typically we capitalize constructor names:</span>
<span class="hljs-keyword">var</span> Quo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(string)</span> </span>{
    <span class="hljs-comment">// add "status" property to new object:</span>
    <span class="hljs-keyword">this</span>.status = string;
    <span class="hljs-comment">// note, no return value needed (the returned object is implicit)</span>
}

<span class="hljs-comment">// add a method to the new prototype:</span>
Quo.prototype.get_status = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.status;
}

<span class="hljs-comment">// invoke constructor:</span>
<span class="hljs-keyword">var</span> q = <span class="hljs-keyword">new</span> Quo(<span class="hljs-string">"confused"</span>);
</code></pre><p>Alternatives:</p>
<pre><code><span class="hljs-keyword">var</span> myobj = <span class="hljs-built_in">Object</span>.create(prototype);
</code></pre><p>This applies the prototype explicitly and avoids using <code>new</code> at all.</p>
<pre><code><span class="hljs-keyword">var</span> mytype = <span class="hljs-keyword">function</span>(spec) {
    <span class="hljs-keyword">var</span> <span class="hljs-literal">that</span> = {}; <span class="hljs-pi">// or Object.create... 
    //</span> initialize <span class="hljs-literal">that</span> according <span class="hljs-keyword">to</span> spec
    <span class="hljs-pi">// define private members as local (var) variables
    //</span> define public members as properties <span class="hljs-keyword">of</span> <span class="hljs-literal">that</span>
    <span class="hljs-pi">// define private methods as local (var) functions
    //</span> assign methods <span class="hljs-keyword">to</span> <span class="hljs-literal">that</span> <span class="hljs-keyword">to</span> make them public
    <span class="hljs-keyword">return</span> <span class="hljs-literal">that</span>;
}
</code></pre><p>This style adds security through the private members/methods, but calling super methods becomes more clunky. It also allows us to procedurally build objects with different capabilities.</p>
<h3 id="json">JSON</h3>
<p>The only syntax difference between object/array and JSON, is that object key names must be quoted:</p>
<pre><code>{ "<span class="hljs-attribute">one</span>": <span class="hljs-value"><span class="hljs-number">1</span> </span>}
</code></pre><p>Most JS environments now provide <code>JSON.parse()</code> and <code>JSON.stringify()</code> wich convert between JSON strings and Javascript objects, and vice versa. Otherwise, JSON libraries are available at json.org. </p>
<h3 id="exceptions">Exceptions</h3>
<p>Throw exceptions with <code>throw &lt;exception-object&gt;;</code>, and catch with the <code>try...catch</code> control flow. A throw will immediately exit the current flow. The exception-object can be anything, but typically an object with <code>.name</code> and <code>.message</code> properties for the <code>catch</code> to deal with:</p>
<pre><code><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">throw</span> { <span class="hljs-string">name:</span> <span class="hljs-string">"MyError"</span>, <span class="hljs-string">message:</span> <span class="hljs-string">"It all went horribly wrong"</span> };
} <span class="hljs-keyword">catch</span> (e) {
    console.log(<span class="hljs-string">"error "</span> + e.name + <span class="hljs-string">": "</span> + e.message);
}
</code></pre><h3 id="regular-expressions">Regular Expressions</h3>
<p>A <em>regular expression</em> specifies the syntax of a simple (type-3) language. They are used to search and replace information from strings. RegExps are usually fast, but are difficult to write (and read!), which means they are common sources of bugs.</p>
<p>A <em>pattern</em> is a template for text that may have fixed and optional or variable components. Patterns either match a strong, or they don&#39;t. A <em>capture</em> within a pattern identifies the part of the pattern that we want to return. </p>
<p>Regular expressions are denoted with <code>/</code> delimiters:</p>
<pre><code><span class="hljs-reserved">var</span> r = <span class="hljs-regexp">/pattern/</span>;
</code></pre><ul>
<li>anchors:<ul>
<li><code>^</code> at the start anchors the pattern at the beginning of the string. Without it, the pattern can skip characters until it finds a matching start point.</li>
<li><code>$</code> at the end anchors the pattern at the end of the string</li>
</ul>
</li>
<li>character classes:<ul>
<li><code>.</code> matches any character</li>
<li><code>[...]</code> describes a set, range or both of characters. E.g. [A-Za-z] matches all alphabetic characters.</li>
<li><code>[^...]</code> as above, but negative: matches any character not in the set described by ...</li>
<li><code>\...</code> is an escape: it is used to match literals such as /, \, ^, $, +, -, *, |, ?, ., {, }, [, ], (, ),  etc. that would otherwise be interpreted as regular expression syntax</li>
<li><code>\d</code> matches any digit, i.e. the same as <code>[0-9]</code></li>
<li><code>\n</code> matches a newline, <code>\t</code> matches tab, <code>\u0041</code> matches &quot;A&quot;, etc.</li>
<li><code>\s</code> matches most whitespace characters</li>
<li><code>\w</code> matches alphabetic and numeric characters</li>
<li><code>\1</code> matches whatever was captured in group 1, etc.</li>
<li>any other characters are literals -- the same character must appear in sequence in the input</li>
</ul>
</li>
<li>modifiers:<ul>
<li><code>?</code> as a suffix means the preceding pattern is optional</li>
<li><code>*</code> as a suffix matches the preceding pattern zero or more times</li>
<li><code>+</code> as a suffix matches the preceding pattern one or more times</li>
<li><code>{3}</code> as a suffix matches the preceding pattern a specific number of times, in this case 3 times.</li>
<li><code>{0,3}</code> as a suffix matches the preceding pattern a specific number of times, in this case 0, 1, 2, or 3 times.</li>
<li><code>a|b</code> the vertical bar | means either a or b will match</li>
</ul>
</li>
<li>captures &amp; groups:<ul>
<li><code>(...)</code> means the pattern in ... should be captured.</li>
<li><code>(?:...)</code> means the pattern in ... is a non-capturing group. It is useful for applying prefix/suffix modifiers to a group without capturing them. </li>
</ul>
</li>
<li>flags (placed after the final <code>/</code>):<ul>
<li>i: ignore case throughout, i.e. <code>e</code> matches both e and E.</li>
<li>m: multi-line, ^ and $ can match line-end characters</li>
<li>g: global, can match multiple times  </li>
</ul>
</li>
</ul>
<p>Use <code>regex.exec(string)</code> to apply the pattern to a string; it will return an array of captures. </p>
<p>Use <code>regex.test(string)</code> to simply test for matches; it will return true or false.</p>
<p><code>string.match(regexp)</code> applies a regular expression to a string. If the g flag is given, it produces an array of all the matches (instead of an array of captures). Otherwise it is the same as <code>regex.exec</code>.</p>
<p><code>string.replace(s, v)</code> replaces all instances of s with v. s can be a regular expression. If s is a string, it only replaces once. v can be a string or a function; if it is a function, it is called for each match and the result used as the replacement. If it is a string, the &quot;$&quot; character has special meaning:</p>
<ul>
<li><code>$&amp;</code> the matched text</li>
<li><code>$1</code> capture group 1</li>
<li><code>$$</code> the &quot;$&quot; character</li>
</ul>
<p><code>string.search(regex)</code>: like <code>string.indexOf</code>. </p>
<h3 id="danger-zone">Danger zone</h3>
<p>Since prototypes are objects, we can add methods to them as we need. This also includes Array.prototype, String.prototype, Object.prototype etc. Adding to these can be convenient, but also dangerous -- especially if the code you are writing will interact with other people&#39;s code. <strong>Never augment built-in prototypes when writing a module.</strong></p>
<p><code>eval()</code> takes a string, parses it as JavaScript, and runs it. <code>setTimeout</code> and <code>setInterval</code> can also take string arguments and use eval. <code>new Function</code> similarly compiles arbitrary code. This capability is extremely powerful, but very very dangerous and difficult to debug.</p>

	</div>
	<footer>
		&copy; 2015 Graham Wakefield
	</footer>
  </body>
</html>