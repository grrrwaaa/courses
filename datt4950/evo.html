<!DOCTYPE html>
<html>
  <head>
	<title>Evolutionary Systems</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="DATT4950">DATT4950</a></li>
<li><a href="due.html" alt="Deliverables">Deliverables</a></li>
<li><a href="gallery.html" alt="Gallery">Gallery</a></li>
<li><a href="themes.html" alt="Themes">Themes</a></li>
<li><a href="cellular.html" alt="Cellular Systems">Cellular Systems</a></li>
<li><a href="agent.html" alt="Agent-Based Systems">Agent-Based Systems</a></li>
<li><a href="evo.html" alt="Evolutionary Systems">Evolutionary Systems</a></li>
<li><a href="labs.html" alt="Labs">Labs</a></li>
<li><a href="js.html" alt="JavaScript">JavaScript</a></li>
	</ul>
	</nav>	
	<div id="main">
	<h1 id="evolutionary-systems">Evolutionary Systems</h1>
<p>There have been more than four decades of computational systems inspired by natural evolution. It has become a major field of machine learning and optimization. Beyond AI, it has been used in hardware and circuit design, robotics, and more recently in industrial design and architecture. It has of course also been deeply explored in art and music.</p>
<p><img src="http://www.karlsims.com/papers/ksf11.gif" alt="Karl Sims"></p>
<h2 id="natural-and-artificial-evolution">Natural and artificial evolution</h2>
<p>The theory of natural evolution combines <strong>population, diversity, heredity and selection</strong>. Evolution requires a <strong>population</strong> of individuals that exhibit <strong>diversity</strong> (both similarities and variations between each other, both within and between species). These individuals can produce new individuals; offspring that exhibit similarites with the parent(s) through <strong>heredity</strong>. However not all of the population can successfully reproduce. Any factor that affects the possibility of an individual reproducing, thus also affects what characteristics are inherited in the population as a whole. Charles Darwin&#39;s theory of natural <strong>selection</strong>, proposed in 1859, is that the section of the population that can reproduce is not entirely random, but rather is regulated by interactions between inherited characteristics and environmental constraints (such as available food, populations of symbionts, predators and parasites, and so on). Accordingly, the characteristics of a species may change over time (<strong>evolution</strong>), forming a history that can be investigated through the fossil records.</p>
<p><img src="img/origin_of_the_species.jpg" alt="Origin of the Species"></p>
<p><strong>Artificial evolution</strong> is a form of computational simulation whose process mirrors the abstract structure of natural evolution:</p>
<ul>
<li>Maintain a population of finite individuals (which can reproduce)</li>
<li>Support variation (including new characteristics) in the population</li>
<li>Provide a mechanism of heredity between generations</li>
<li>Provide a mechanism of selection </li>
</ul>
<p>The main systematic differences are that the underlying mechanisms specified by us in advance, as are the initial populations and environmental conditions (if any). Most importantly, <em>the mechanism of selection is usually predetermined</em>. And of course, artificial evolution occurs in a much simpler substrate than real chemistry.</p>
<p><a href="http://www.talkorigins.org/faqs/genalg/genalg.html#examples">A fantastic list of practical applications of genetic algorithm &amp; evolutionary programming</a> </p>
<h3 id="some-inspiration">Some inspiration</h3>
<p><a href="http://www.karlsims.com/genetic-images.html">Karl Sims&#39; Genetic Images</a> -- and the <a href="http://www.karlsims.com/papers/siggraph91.html">1991 Siggraph Paper</a></p>
<p><a href="http://www.karlsims.com/evolved-virtual-creatures.html">Karl Sims: Evolving 3D Morphology and Behavior by Competition, 1994</a>:</p>
<iframe width="420" height="315" src="https://www.youtube.com/embed/JBgG_VSP7f8" frameborder="0" allowfullscreen></iframe>

<p><a href="http://draves.org/aoae07/draves-aoae07.pdf">Scott Draves, “Evolution and Collective Intelligence of the Electric Sheep,” The Art of Artificial Evolution, 2008.</a></p>
<iframe src="https://player.vimeo.com/video/22469941" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p><a href="https://vimeo.com/22469941">High Fidelity Sample</a> from <a href="https://vimeo.com/user4921556">Scott Draves</a> on <a href="https://vimeo.com">Vimeo</a>.</p>

<a href="http://boxcar2d.com/">Evolving 2D cars</a>

<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=z9ptOeByLA4">Evolving soft robots</a>

Evolving neural networks to play Mario:

<iframe width="560" height="315" src="https://www.youtube.com/embed/S9Y_I9vY8Qw" frameborder="0" allowfullscreen></iframe>

<p>An excellent discussion of <a href="http://www.youtube.com/watch?v=50-d_J0hKz0">the genetic algorithm in art and its relation to Deleuze, by Manuel Delanda</a></p>
<h3 id="subtleties-and-misconceptions">Subtleties and misconceptions</h3>
<p>Darwin&#39;s theory is sometimes misconceived as &quot;survival of the fittest&quot; or even the competitive &quot;law of the jungle&quot;, but evolution turns out to be quite a bit more subtle than this.</p>
<ul>
<li><p>First, the <em>notion of &quot;fittest&quot; is misleading</em>. It implies a static and absolute measure against which all individuals and species in the biological record can be compared. In natural evolution there can be no pre-defined (<em>a priori</em>) fitness measure. This is because the environmental conditions are highly dynamic, and thus selective criteria are quite contextual. The conditions in which we live evolve along with us, and the other species in our habitat, as we mutually influence each other. Evolution is an open-ended process. </p>
</li>
<li><p>The complication of living in an ever-changing environment means that no one strategy can be universally superior. This is sometimes referred to as the &quot;no free lunch&quot; theorem, which is more accurately stated that &quot;if an algorithm performs well on a certain class of problems then it necessarily pays for that with degraded performance on the set of all remaining problems.&quot; (Wolpert, D.H., Macready, W.G. (1997), &quot;No Free Lunch Theorems for Optimization&quot;, IEEE Transactions on Evolutionary Computation 1, 67.)</p>
</li>
<li><p>Since there is no absolute goal or progress, the most we can measure in natural evolution is the changing frequencies over time of individual species, or of individual characteristics of a population. More importantly, evolution cannot be said to have a singular direction. That is to say, it is goal-less (<em>non-teleological</em>), and thus, counter to common opinion, <em>natural evolution does not imply progress</em>. </p>
</li>
<li><p>Nor is evolution a continuous process of change. The fossil records appear to show long periods of relative stability divided by relatively brief periods of biological invention. There are several competing theories as to why, but interestingly this &quot;<em>punctuated equilibrium</em>&quot; has appeared also in many artificial evolutionary systems.</p>
</li>
<li><p>An individual organism does not need to be optimally fit to the environment in order to contribute to the gene pool -- it simply needs to be <em>fit enough</em> to survive long enough to reproduce, i.e. to be <em>viable</em>. he survival of a natural species depends primarily on its <em>viability</em>; the ability of enough individuals to live long enough to reproduce within an unpredictable environment. </p>
</li>
<li><p>Evolution does not act on every facet of an organism, only those that directly influence viability (in the current environment). If a variation has neither positive or negative impact on the reproductive capability of an individual in the environment, this variation is called <strong>neutral</strong>. Since small variations are always occurring, neutral variations can tend to accumulate over time. Over time the gene pool may broaden and move quite far from its origin without causing any major changes in selective viability; this is called <strong>neutral drift</strong>.  This may be an important mechanism to escape evolutionary dead-ends (local minima in the fitness landscape). This is certainly true for many artificial evolutionary systems. It has also been hypothesized as an explanation for the long chunks of apparently unused DNA in our own genome, and also for punctuated equilibrium.</p>
</li>
<li><p>Competition turns out not to be the prime mode of interaction between species; most species are relatively independent, and the ones that do closely interact are more likely to be collaborative (symbiotic, parasitic, etc.) than competitive, as that is more likely to lead to viability. Like our society, the natural environment is complex enough to provide multiple methods of making a living. Evolution does not imply that individuals display selfish, competitive behavior. When Dawkins described evolution in terms of <a href="http://en.wikipedia.org/wiki/The_Selfish_Gene">selfish genes</a>, it indicates a gene-centric perspective on evolution that implies selfless and sometimes altruistic behavior in organisms. Nevertheless, there is a sense in which competition applies, as with <a href="http://en.wikipedia.org/wiki/Red_Queen_hypothesis">red queen</a> hypothesis: that organisms must constantly adapt, evolve, and proliferate not merely to gain advantage in reproductive viability, but also simply to survive while pitted against an ever-evolving context. However it is not clear whether a simple &quot;arms race&quot; is a sufficient perspective, or whether more complex and even abiotic factors may be more significant.</p>
</li>
<li><p>Evolution by itself is not particularly creative, and its importance may have been over-stated. A continuous generation of novel diversity, new characteristics, is essential to the theory of natural selection. However the theory does not account for how diversity arises, simply that there must be a mechanism, which usually operates during reproduction. </p>
</li>
</ul>
<h3 id="heredity-and-variation-genetics">Heredity and variation: genetics</h3>
<p>In 1865 Mendel proposed that characteristics are transmitted to offspring through particles of matter (which we now call <strong>genetic material</strong>). Schroedinger conjectured that these materials must be aperiodic crystals, and the actual structure of DNA was identified several years later. The <em>&quot;modern synthesis&quot;</em> in biology today has integrated genetics with natural evolution, through the interaction of genotypes and phenotypes:</p>
<ul>
<li>The <strong>phenotype</strong> is the manifestation of the genotype, the individual organism in the population. It is physical and dynamic. Natural selection only operates on the phenotypic level.</li>
<li>The <strong>genotype</strong> is the genetic material that is transmitted during reproduction. It encodes information that is usually static during a lifetime. Different information leads to different phenotypic variations, or even different species. Heritable variation and the creation of new characteristics operates only at the genotypic level. </li>
</ul>
<p>Hence the modern synthesis requires not only a model for how variation is introduced, but also how genetic material is transfered, how the phenotype accordingly emerges from the genotype (<em>developmental models</em>), and what other roles it plays. It is increasingly being understood how the complexity of the environment and materials of life are likely as much or more responsible for the variety of life than the genes themselves, however, these mechanisms are still in the progress of being revealed.</p>
<blockquote>
<p>Briefly: a biological cell contains a vast array of different proteins, whose concentrations determine structures and behaviors of the cell. The proteins are specifed by information in the DNA genetic material (grouped physically into <strong>chromosomes</strong>). When a cell reproduces by <strong>mitosis</strong>, a copy of the DNA is made in the new cell. The sections of a DNA chromosome that code for behavior are called <strong>genes</strong>. These regions are constantly being <strong>transcribed</strong>, producing a specific RNA strand for each coding gene region which is in turn used to produce a specific protein; the protein string immediately folds up (in a way we cannot yet simulate) into a particular reactive shape which specifies the protein&#39;s behavioral role in the cell. This is a one-directional flow of information: Coding DNA -&gt; RNA -&gt; folding -&gt; active protein. In addition to coding regions genes may also have  <strong>regulatory region</strong> which can react with specific proteins to activate or inhibit the coding-protein system, forming a complex <strong>regulatory network</strong> of interactions by which one gene can activate or inhibit another, and also specify changes of behavior of a cell according to environmental conditions such as chemical signals. These networks can be fantastically complex even in very simple organisms, according to the scientific results of <strong>functional genomics</strong>. Between the coding and regulatory regions of DNA, there are huge sections of <strong>nongenic</strong> DNA, whose role (or lack thereof) is not yet understood.</p>
</blockquote>
<p><img src="img/transcription.jpg" alt="Rendering"></p>
<p><a href="http://www.youtube.com/watch?v=WFCvkkDSfIU">The current theory of cell replication and DNA transcription been beautifully illustrated by Drew Berry</a>; and <a href="http://www.youtube.com/watch?v=yKW4F0Nu-UY&amp;list=PL3DB3C131CBCD2A0F&amp;index=5">more of his animations here</a></p>
<p>Genetic variation can occur during replication of the genome, such as copying-error <em>mutations</em> (reversals of segments, insertion &amp; removal of segments, changing individual elements in the sequence, and pair-wise substitution over whole sections) and <em>recombination</em> (taking sections from two different parent genes to construct a new child gene). </p>
<h2 id="artificial-evolution">Artificial evolution</h2>
<p>An artificial evolutionary system thus requires:</p>
<ol>
<li>A representation of genotypes.</li>
<li>A mechanism to produce phenotypes from genotypes (development).</li>
<li>Mechanisms to introduce diversity to a genotype.</li>
<li>A mechanism to evaluate the fitness (or viability) of phenotypes.</li>
</ol>
<p>These components must be provided by the author. The system is then run by these steps:</p>
<ol>
<li><strong>Initialization</strong> of a &#39;seed&#39; population of genotypes</li>
<li><strong>Development</strong> of phenotypes from the genotypes </li>
<li>Evaluation and <strong>selection</strong> of best/viable candidates of phenotypes, according to fitness criteria or ongong viability conditions, to choose who may reproduce.</li>
<li><strong>Reproduction</strong>, creating new genotypes by applying mechanisms of variation, according to variation rates/probabilities.</li>
<li>Repeat from step (2) or terminate if a terminating condition is satisfied (such as sufficient fitness). </li>
</ol>
<p>Steps 2-5 may be run in lock-step, or asynchronously with overlapping individual life-spans.</p>
<h3 id="genetic-representation">Genetic representation</h3>
<p>Many systems represent genetic information as a sequence of data, such as a string of characters or binary digits. Some systems use more elaborate structures (trees, networks), but these are usually reducible to and encoded as  linear sequences. After all, our genes wind up in complex structures with different reactive regions, but at the lowest level are just a long singular chain of A, G, C or T molecules.</p>
<p>The simplest systems have a fixed length, but nature shows quite a lot of variance (not particularly correlated with the size, complexity, or evolutionary age of a species). </p>
<p>Initializing the genotypes implies generating randomized candidates that stay within its bounds but hopefully give a sufficiently diverse range of the possibilities of the genotype. For a simple sequence of bits, symbols, or numbers, this is fairly easy to do.</p>
<h3 id="development">Development</h3>
<p>In some systems the developmental process is little more than a trivial mapping, but this potentially misses an entire and fascinating source of diversity. Incorporating more complex developmental models can lead to geometric variations that are not stored as simple parameters, to repeated segments and recursive structures, to symmetries, and to the re-application of common toolboxes toward a widely differing set of purposes -- all things that are evident in biological evolution. </p>
<h3 id="selection">Selection</h3>
<p><strong>For problem solving in data mining, engineering, design, architecture, etc.</strong>: If the fitness criterion is static and designed around a particular problem we wish to find a solution for, evolution can help evaluate &amp; test candidate solutions and selectively breed them to produce better solutions, ideally converging on an optimal one, without having to understand or derive by proof. It is a form of optimization. However this process may take a long time or a lot of processing power to find a satisfactory result, or may not reach a result at all. Not all problems are suitable for evolutionary search.</p>
<p>Evidently, these systems differ markedly from natural evolution by having a static measure, and thus a singular teleological character, a meaningful sense of progress, across the entire history of the system. This is more akin to <em>selective breeding</em> than natural evolution. </p>
<p>Note that simply taking the best candidate alone is not necessarily the ideal strategy; selecting randomly by proportion to fitness (&quot;roulette wheel&quot; selection) may better overcome local maxima.</p>
<p><strong>For art, music, and other less formalized domains</strong> we may need to consider other methods of selection, since a formal measure may not be possible, or the problem may not be clearly statable in advance. E.g. can we measure aesthetic quality in formal terms?</p>
<ul>
<li>Interactive selection. Pioneered by Dawkins&#39; Biomorphs program and Karl Sims&#39; evolved images, in which several candidates are presented to human observers, who apply the selection manually. Also known as aesthetic selection. A problem here is that the human becomes the bottleneck of evolution, constraining population sizes and rates of evolution to very small scales. It may arguably also tend toward selecting for the aesthetic average rather than the remarkable.<ul>
<li>An interesting variation is to make the selection continuous and implicit. Jon McCormack&#39;s Eden measured fitness globally according to how long gallery visitors remained in front of a particular evolving sub-population.</li>
</ul>
</li>
<li>Evolved/evolving selection. First evolve a population of artificial art critics, trained from human-evaluated examples, and then use these to apply selection criteria to a population of candidate artworks. Some projects have also proposed a form where one population represents the candidate products, and the other population represents artificial critics.</li>
<li>A viability-oriented form of artificial evolution may be used for more theoretical and aesthetic branches of artificial life research. The viability measure arises as an emergent property of underlying laws of the world, such as the requirement to maintain energetic/metabolic balance or to maintain structural integrity, as well as the collective effects of multiple species and non-living dynamics within the environment. For this reason it is sometimes referred to as <em>ecosystemic selection</em>. <a href="http://link.springer.com/chapter/10.1007%2F978-3-540-78761-7_42">See discussion here</a>. This may still incorporate indirect interaction from human agents if desired.</li>
</ul>
<h3 id="variation">Variation</h3>
<p>The mechanisms of variation possible partly depend on the representation chosen. The two most common principles of variation in artificial evolution are naturally inspired:</p>
<ul>
<li>Random <strong>mutation</strong>; akin to errors copying DNA. If the genome is represented as a binary string, then random locations in the string may be replaced by new random characters. For example, a parent &quot;dog&quot; could produce children such as &quot;fog&quot;, &quot;dqg&quot;, and so on. Obviously some mutations will not create viable individuals.</li>
<li>Sexual <strong>cross-over</strong>: akin to sexual reproduction in biology. As a binary string, the child takes the first fraction from one parent, and the remainder from the other. For example, breeding the strings &quot;dog&quot; and &quot;cat&quot; could generate children such as &quot;dot&quot;, &quot;dat&quot;, &quot;cag&quot; and &quot;cog&quot;. </li>
<li>Other forms of fragment <strong>recombination</strong>, such as insertion, deletion, reversal. So a more flexible system might also permit &quot;doat&quot;, &quot;caog&quot;, &quot;dt&quot;, &quot;tac&quot;, etc. </li>
</ul>
<blockquote>
<p>Why use reproduction for evolution? In the face of an unpredictable environment, we cannot know which strategy will be best; we can try small variations, and hedge our bets by making very many of them (population diversity). An individual loss is not catastrophic, but a few successes can be learned from. Furthermore, the face of unpredictibility implies that what was true today may not be tomorrow, so the flexibility to avoid timeless commitment is also a good strategy; but the inheritance of choices is a useful option when the environment retains some stability. If the world were fully predictable, a rational, teleological, monothematic strategy would be preferable. But the world isn&#39;t totally random either (if it was, there would be no valid strategy worth pursuing.) </p>
</blockquote>
<p>As with temperature-like parameters we saw in CA, a crucial factor in evolution is the rate or probability of variation. Too much, and the population may never significantly diverge from a randomly initialized one; too little, and it may find itself stuck on the first solution it finds, with a largely homogenous population. It may be wise to have different mutation rates for different genes, or for different members of a population, or by fitness rank etc. It is likely desirable to gradually reduce mutation rates over time, unless the population appears to be stagnating. (See also simulated annealing.)</p>
<hr>
<h2 id="a-trivial-string-generator">A trivial string generator</h2>
<p>Just to practice the mechanics, we can start by evolving sentences toward a desired result. Each gene is an integer, which is mapped to a word from a predefined list:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// the desired result:</span>
var target = <span class="hljs-string">"the quick brown fox jumped over the lazy dog"</span><span class="hljs-comment">;</span>

<span class="hljs-comment">// the set of components:</span>
var dictionary = [<span class="hljs-string">"I"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"an"</span>, <span class="hljs-string">"bleep"</span>, <span class="hljs-string">"blown"</span>, <span class="hljs-string">"bog"</span>, <span class="hljs-string">"box"</span>, <span class="hljs-string">"broad"</span>, <span class="hljs-string">"brown"</span>, <span class="hljs-string">"bumped"</span>, 
    <span class="hljs-string">"cat"</span>, <span class="hljs-string">"cog"</span>, <span class="hljs-string">"coloured"</span>, <span class="hljs-string">"colourful"</span>, <span class="hljs-string">"colourless"</span>, <span class="hljs-string">"crazy"</span>, <span class="hljs-string">"creep"</span>, <span class="hljs-string">"crown"</span>, <span class="hljs-string">"dig"</span>, 
    <span class="hljs-string">"do"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"door"</span>, <span class="hljs-string">"dot"</span>, <span class="hljs-string">"ever"</span>, <span class="hljs-string">"fit"</span>, <span class="hljs-string">"fix"</span>, <span class="hljs-string">"flick"</span>, <span class="hljs-string">"for"</span>, <span class="hljs-string">"fox"</span>, <span class="hljs-string">"frown"</span>, 
    <span class="hljs-string">"glean"</span>, <span class="hljs-string">"great"</span>, <span class="hljs-string">"greed"</span>, <span class="hljs-string">"green"</span>, <span class="hljs-string">"greet"</span>, <span class="hljs-string">"hazy"</span>, <span class="hljs-string">"he"</span>, <span class="hljs-string">"hog"</span>, <span class="hljs-string">"ideas"</span>, <span class="hljs-string">"idols"</span>, 
    <span class="hljs-string">"in"</span>, <span class="hljs-string">"it"</span>, <span class="hljs-string">"jumble"</span>, <span class="hljs-string">"jumped"</span>, <span class="hljs-string">"jumper"</span>, <span class="hljs-string">"jumps"</span>, <span class="hljs-string">"last"</span>, <span class="hljs-string">"lazy"</span>, <span class="hljs-string">"leaped"</span>, <span class="hljs-string">"lumped"</span>, 
    <span class="hljs-string">"maze"</span>, <span class="hljs-string">"of"</span>, <span class="hljs-string">"offer"</span>, <span class="hljs-string">"ogre"</span>, <span class="hljs-string">"older"</span>, <span class="hljs-string">"on"</span>, <span class="hljs-string">"or"</span>, <span class="hljs-string">"over"</span>, <span class="hljs-string">"quick"</span>, <span class="hljs-string">"quite"</span>, <span class="hljs-string">"rapid"</span>, 
    <span class="hljs-string">"she"</span>, <span class="hljs-string">"sheen"</span>, <span class="hljs-string">"sheep"</span>, <span class="hljs-string">"sick"</span>, <span class="hljs-string">"sleep"</span>, <span class="hljs-string">"slept"</span>, <span class="hljs-string">"slow"</span>, <span class="hljs-string">"spelt"</span>, <span class="hljs-string">"spilt"</span>, <span class="hljs-string">"the"</span>, 
    <span class="hljs-string">"town"</span>, <span class="hljs-string">"under"</span>]<span class="hljs-comment">;</span>

<span class="hljs-comment">// initial:</span>
var geno = []<span class="hljs-comment">;</span>
<span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 9; i++) {</span>
    geno[i] = random(dictionary.<span class="hljs-keyword">length</span>)<span class="hljs-comment">;</span>
}
<span class="hljs-comment">// develop:</span>
var pheno = []<span class="hljs-comment">;</span>
<span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i &lt; geno.length; i++) {</span>
    pheno[i] = dictionary[ geno[i] ]<span class="hljs-comment">;</span>
}
pheno = pheno.join(<span class="hljs-string">" "</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>To evaluate, we could compare how many of the right characters are in the right places:</p>
<pre><code class="lang-javascript">var <span class="hljs-keyword">err</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i &lt; pheno.length; i++) {</span>
    <span class="hljs-keyword">if</span> (pheno.substr(i, <span class="hljs-number">1</span>) != target.substr(i, <span class="hljs-number">1</span>)) {
        <span class="hljs-keyword">err</span>++<span class="hljs-comment">;</span>
    }
}
<span class="hljs-comment">// make it fair between long &amp; short strings:</span>
<span class="hljs-keyword">err</span> /= pheno.<span class="hljs-keyword">length</span><span class="hljs-comment">;</span>
</code></pre>
<p>To convert this error into a fitness, where fittest is 1 and least fit is zero, we could apply a <code>1/(1+n)</code> mapping:</p>
<pre><code class="lang-javascript">var fitness = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + <span class="hljs-keyword">err</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>This gives us all the basic components we need to generate a random population as genotypes. We already know how to develop and evaluate such a genotype, and storing several in a population is trivial. </p>
<p>It is generally useful to sort a population by fitness, which can be done like so:</p>
<pre><code class="lang-javascript">// sort the population by comparing pairs
// <span class="hljs-keyword">as</span> a <span class="hljs-literal">result</span>, the fittest candidate will be <span class="hljs-keyword">in</span> population[<span class="hljs-number">0</span>]
population.sort(function(a, b) { <span class="hljs-keyword">return</span> b.fitness - a.fitness; });
</code></pre>
<blockquote>
<p>After sorting it is convenient to print out the candidates, their fitness, etc, so we can see how the evolution proceeds.</p>
</blockquote>
<p>After evaluating, we create a new generation of candidates, broadly derived from the previous, but with fitter candidates being more likely to be progenitors. The simplest method is to pick a parent at random, but biasing toward the lower indices. (A simple trick to do this is for the nth child to use a the parent at index <code>random(n)</code>.)</p>
<blockquote>
<p>This is called <em>stochastic universal sampling</em>: it draws samples from the entire range, but selects fitter individuals more often than less-fit candidates.</p>
</blockquote>
<p>We must also introduce some variation (mutations) while generating new genotypes at this point. The simplest method is to introduce a branch with a predetermined probability to randomize a gene rather than copy from the parent, e.g.:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// copy or mutate genes:</span>
<span class="hljs-keyword">for</span> (var <span class="hljs-keyword">j</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">j</span> &lt; gene_size; <span class="hljs-keyword">j</span>++) {
    <span class="hljs-comment">// mutate?</span>
    <span class="hljs-keyword">if</span> (random() &lt; mutability) {
        child[<span class="hljs-keyword">j</span>] = random(gene_range); 
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// copy:</span>
        child[<span class="hljs-keyword">j</span>] = parent[<span class="hljs-keyword">j</span>];
    }
}
</code></pre>
<p>Does it work? If not, can you think of ideas why -- and any ideas to improve it?</p>
<p><a href="http://codepen.io/grrrwaaa/pen/yeqMYy?editors=001">Here&#39;s something like this in the editor</a>.</p>
<h2 id="a-simple-math-solver">A simple math solver</h2>
<p>The string example was a little silly, but let&#39;s say we want to write a program (the phenotype) that can solve math problems. To start as simple as possible, we can restrict our programs to numerals and symbols of basic arithmetic:</p>
<pre><code class="lang-javascript"><span class="hljs-variable"><span class="hljs-keyword">var</span> symbols</span> = [<span class="hljs-string">"+"</span>, <span class="hljs-string">"-"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"/"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>, <span class="hljs-string">"6"</span>, <span class="hljs-string">"7"</span>, <span class="hljs-string">"8"</span>, <span class="hljs-string">"9"</span>, <span class="hljs-string">"0"</span>];
</code></pre>
<p>To generate a random program, of say, length 10 characters, and run it, we would do something like this:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// fill an array:</span>
var arr = []<span class="hljs-comment">;</span>
<span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;10; i++) {</span>
    <span class="hljs-comment">// pick a symbol at random to add:</span>
    arr[i] = symbols[random(symbols.<span class="hljs-keyword">length</span>)]<span class="hljs-comment">;</span>
}
<span class="hljs-comment">// convert the array of symbols to a string of code:</span>
var code = <span class="hljs-string">"return "</span> + arr.join(<span class="hljs-string">""</span>)<span class="hljs-comment">;</span>
<span class="hljs-comment">// convert to an executable function:</span>
var f = new Function(code)<span class="hljs-comment">;</span>
<span class="hljs-comment">// run it to get the result</span>
console.log(f())<span class="hljs-comment">;</span>
</code></pre>
<p>The chances are, the generated code is garbage, and might well throw an error, or return a meaningless result such as <code>Infinity</code> or <code>NaN</code>. These errors could break or throw off our simulation, but we can trap them safely as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">try</span> {
    // convert to an executable function:
    <span class="hljs-keyword">var</span> f = new <span class="hljs-type">Function</span>(code);
    // run it to get the <span class="hljs-literal">result</span>
    <span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = f();
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">result</span> != <span class="hljs-type">Infinity</span> &amp;&amp; <span class="hljs-literal">result</span> != -<span class="hljs-type">Infinity</span> &amp;&amp; <span class="hljs-literal">result</span> == <span class="hljs-literal">result</span>) {
        console.log(<span class="hljs-literal">result</span>);
    }
}
</code></pre>
<p>Now we can evaluate the fitness of our result, relative to a target number. We can take the absolute difference, and then put this through a <code>1/(1+n)</code> mapping as before. This mapping is somewhat arbitrary, but works for our purposes here:</p>
<pre><code class="lang-javascript">fitness = <span class="hljs-number">1</span> / <span class="hljs-number">1</span> + (<span class="hljs-type">Math</span>.abs(<span class="hljs-literal">result</span> - target));
</code></pre>
<hr>
<p><a href="http://codepen.io/grrrwaaa/pen/zrLZvK?editors=001">Here&#39;s something like this in the editor</a>.</p>
<p>With this in play, we should already see some clear evolutionary behaviour. You may notice punctuated equilibria. Run the simulation many times, and you may notice that the fittest candidate is not always converging to the same result. There are clearly multiple distant fitness peaks here. </p>
<p>You may notice that the code generated sometimes looks odd -- and that the evolution has discovered tricks such as adding numbers multiplied by zero, prefixing zeroes to numbers, and even placing two slashes to create a comment (followed by &quot;junk DNA&quot;), in order to get a result with the specific gene length. We could easily prevent this by turning our <code>&quot;/&quot;</code> symbol into a <code>&quot; / &quot;</code> symbol, but perhaps there is an advantage not to?</p>
<p>Try changing the genome size, the population size, and the mutation rates, to see how it changes. </p>
<p>Try playing with the symbol list. What happens if you add the &quot;.&quot; character? How about &quot;(&quot; and &quot;)&quot;?</p>
<p>The mutation rate acts a bit like a temperature control -- too high and good results can&#39;t remain viable, too low and it takes to long to get anywhere. Larger populations help to generate more chances of leaping off a local peak. Too short genome sizes can be a tough challenge, but too long genomes make it less likely to find a result quickly -- and add more noise. Is there a way to make genome size variable, and give shorter results higher fitness? What other mutation methods could help? What other developmental models could be tried? Is there a better way to pick parents?</p>
<p>Generally, by observing the behaviour, what insights can you draw, and what ideas have you for improving it?</p>
<p>How would you be able to add operators such as <code>Math.sin()</code>?  </p>
<p>What other problems could you imagine addressing, other than calculating numbers? (What kinds of problems is this method suited for?)</p>
<hr>
<h2 id="aesthetic-selection-of-biomorphs">Aesthetic selection of biomorphs</h2>
<p>Biomorphs are virtual entities that were devised by Richard Dawkins in his book <a href="https://en.wikipedia.org/wiki/The_Blind_Watchmaker">The Blind Watchmaker</a> as a way to visualize the power of evolution. Dawkins used a simple symbolic rendering of lines at fixed angles, grown in a kind of tree structure, as his phenotypes. Of a given generation, he selected the biomorph he found most aesthetically pleasing, making this the parent of the next generation.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/fc/BiomorphBounce.png" alt="biomorph"></p>
<blockquote>
<p>Adding new lines (or removing them) based on simple developmental rules offered a discrete set of possible new shapes (mutations), which were displayed on screen so that the user could choose between them. The chosen mutation would then be the basis for another generation of biomorph mutants to be chosen from, and so on. Thus, the user, by selection, could steer the evolution of biomorphs. This process often produced images which were reminiscent of real organisms for instance beetles, bats, or trees. Dawkins speculated that the unnatural selection role played by the user in this program could be replaced by a more natural agent if, for example, colourful biomorphs could be selected by butterflies or other insects, via a touch sensitive display set up in a garden.</p>
</blockquote>
<h3 id="turtle-graphics">Turtle graphics</h3>
<p>One of the simplest ways to create a biomorph is to interpret strings as instructions for another program. The genotype is a string of symbols, the phenotype is the graphics that result. The classic example is using them as instructions for a &quot;turtle graphics&quot; interpreter. Our alphabet &amp; semantics could be something like this:</p>
<ul>
<li><strong>F</strong>: move forward one unit, drawing a line.</li>
<li><strong>f</strong>: move forward half a unit, drawing a line.</li>
<li><strong>+</strong>: turn a fixed amount to the left.</li>
<li><strong>-</strong>: turn a fixed amount to the right.</li>
<li><strong>=</strong>: spawn a new turtle, facing the opposite direction, and let both turtles continue following the instructions.</li>
<li><strong>.</strong>: do nothing</li>
<li>etc.</li>
</ul>
<p>One of the advantages of using strings of symbols as genotypes is their readability, but another is the flexibility to perform different kinds of mutations:</p>
<ul>
<li>Replace a symbol with another randomly chosen from the alphabet</li>
<li>At a random location, remove a symbol</li>
<li>At a random location, insert a symbol randomly chosen from the alphabet</li>
<li>Split the string into two parts, and join them the other way around</li>
<li>Reverse a section of the string</li>
</ul>
<p>Now we can show all members of a generation side-by-side, and use the mouse to choose the member we prefer to form the parent of the next generation.</p>
<p>Possible extensions:</p>
<ul>
<li>Make the fixed amounts variable over time</li>
<li>Add &quot;bracketed systems&quot;:<ul>
<li>By adding push &quot;[&quot; and pop &quot;]&quot; symbols to save/restore graphics state (position, orientation etc.), the graphics interpreter can render branched structures such as trees and ferns. The result is further improved by reducing the length of each line according to the bracketed recursion depth.</li>
</ul>
</li>
<li>Extend into <em>rewriting systems</em>, such as L-systems, by embedding <em>production rules</em> -- we will return to this later in the course.</li>
</ul>
<hr>
<h2 id="pause">Pause</h2>
<p>At this point, it is becoming clear that the effectiveness of evolution depends very much on the genetic representation, and its semantics. It may be useful to consider this an <em>intermediate language</em>. What does this mean? A very common and very general method of solving problems (mathematical, computational, and otherwise), is to translate the problem into a more convenient language. We saw that our agents could reason about neighbours more easily when the neighbour poses where translated out of global space and into the coordinate space of the agent itself. Similarly, the turtle graphics language made it very easy to create simple line drawings, and with just a handful of special tokens quite complex structures, but there are still many shapes this language is unable or very unlikely to express. Simply, some languages work better than others for certain problems. This may related to the reason why so many species share huge sequences of the same DNA. </p>
<p>We don&#39;t want to make our intermediate language to too restrictive, else it will not be powerful and extensible enough to encompass a wide enough range of expected and unexpected solutions. For example, we saw how creating an intermediate language of predefined words ensured we have readable (if nonsense) sentences, whereas translating into random numbers and arithmetic symbols opened the possibility of invalid expressions, but also was able to discover unexpected methods (such as using comment symbols for neutral drift). However, we also don&#39;t want our intermediate language so powerful and extensible that it becomes inefficient or intractable to actually apply, or upon which evolution has barely a chance to have impact. </p>
<p>There are clearly two sides to this: the <em>syntax</em> of the language, which mainly affects how mutations can be applied, and what kinds of transformations result; and the <em>semantics</em> of the language, which define the basic primitive concepts from which phenotypes are produced, and the potential variety in the population.</p>
<hr>
<h2 id="evolving-agents">Evolving agents</h2>
<p>For a more ambitious, but more interesting challenge, we can try to build up a population of evolving agents whose phenotypic behaviour is a unique <em>program</em>, which processes information from the environment through a number of internal &quot;neural nodes&quot;, resulting in actions, or actuator potential signals that in turn cause actions in the exterior world. </p>
<p><img src="img/agent_diagram.png" alt="agent diagram"> </p>
<p><strong>Possible outputs include:</strong></p>
<ul>
<li>Changing internal mental states, such as memory stores, or dispositions.</li>
<li>Locomotion. Ideally modeled as signals sent to simulated locomotory systems, rather than simple changes of velocity/orientation. </li>
<li>Consumption. Extraction of materials from the environment, e.g. food. <ul>
<li>Vice versa, expulsion of materials back into the environment, e.g. building, defecation. </li>
</ul>
</li>
<li>Communication. Pheromone deposits, noises, visual signals, etc.</li>
<li>Growth. Although this is not usually something under an organisms&#39; control for larger organisms, it may be at the cellular level.</li>
<li>Reproduction. Clearly this is only an internal choice for organisms that reproduce asexually.</li>
</ul>
<blockquote>
<p>If it is helpful, you may imagine the buttons you can press to control a videogame character. Each button is an output.</p>
</blockquote>
<p><strong>Possible inputs include:</strong></p>
<ul>
<li>Internal physiological states: At least, the current store of energy (the hungry/satiated axis), but possibly also other internal parametric states if they exist, such as temperature, digestive toxicity, ...</li>
<li>Smell/taste/pressure/humidity/electroreception/magnetoception: Detection of concentrations/intensities in local fields, at the center location of the agent.<ul>
<li>Alternatively, sensors on appendages: same as above, but at points removed from the center of the agent according to the bodily position of the sensor. E.g. eyestalks.</li>
</ul>
</li>
<li>Touch: Detection of collision with objects in the environment. Could be a simple boolean true/false, could include a direction to the collided object, could include a magnitude according to the amount of overlap (i.e. a vector). </li>
<li>Proximity/sight/hearing/echolocation: Detection of the number of agents/objects in close range. Could be converted to a loneliness/claustrophobia axis.<ul>
<li>Or perhaps the center-of-mass of objects/agents in close range (the <em>cohesion</em> and <em>separation</em> senses of the boids), or some other average property of nearby objects/agents (such as the <em>alignment</em> sense of the boids, or perhaps average color of nearby agents). </li>
<li>Could be refined to multiple senses, for different kinds of objects.</li>
</ul>
</li>
<li>Proprioception/vestibular senses: The sense of motion from within, including balance, poise, etc. The simplest could be an accelerometer, reporting changes of velocity back to the agent. There could also be senses identifying the position or rate of movement of limbs.</li>
<li>Temporal senses (Chronoception): The simplest being a function of the agent&#39;s age since birth.</li>
<li>Pain (nociception), and perhaps other stimulations, triggered by other activity upon the agent, which dissipates over time.</li>
<li>Internal mental states, such as memory or dispositions: Could simply be a bank of memory &quot;slots&quot;, that are written as one of the action outputs.</li>
</ul>
<p>It is likely necessary to conform inputs to ranges of sensitivity, such that external quantities are always mapped into internal ranges clamped in a unipolar 0..1 range, or perhaps a bipolar -1..1 range. Outputs may also need to map their intrinsic ranges (unipolar or bipolar) into useful ranges in the world. For example, a unipolar consumption range could be used as a proportion of available food that is actually ingested. Alternatively, it could be mapped to a range determined by the maximum eating rate an organism can sustain (a constant).</p>
<p>For both inputs and outputs, we may need to distinguish between occasional &quot;events&quot; (think of buttons and impacts) and more continuously varying &quot;signals&quot; (think of knobs and rotations), though it is simpler if we do not need to. </p>
<blockquote>
<p>Event-like inputs can be treated as signals whose value is zero when no event is occurring. Event-like outputs can be treated as signals that pass a given threshold, or change by a significant margin. Thresholding is a general way to convert a signal to an event, possibly with some accumulation &amp; relaxation time, and sampling is a way to convert an event into a signal, possibly with some averaging/smoothing.</p>
</blockquote>
<p><strong>Possible internal operations:</strong></p>
<p>The middle layers between inputs &amp; outputs may utilize a palette of mathematical mappings and simple signal-processing operators. For example, the set of &quot;neural nodes&quot; available in Karl Sims&#39; <a href="http://www.karlsims.com/papers/siggraph94.pdf">evolving virtual creatures</a> simulation included:</p>
<blockquote>
<p>sum, product, divide, greater-than, sign-of, min, max, abs, if, interpolate, sin, cos, atan, log, expt, sigmoid, </p>
</blockquote>
<p>Furthermore, a number of more complex &quot;stateful&quot; operators (i.e. operators which include their own history/memory) were included:</p>
<blockquote>
<p>sum-threshold, integrate, differentiate, smooth, oscillate-wave, and oscillate-saw.</p>
</blockquote>
<p>Sum-threshold refers to a unit that operates much like a real neuron, accumulating inputs until a threshold is reached, then outputting a pulse and relaxing to zero. Integrate is a simple counter, but it may be wise to make it &quot;leaky&quot;, such that the accumulated value naturally decays over time. Smooth is a simple moving average, or low-pass filter, such as averaging the current and previous input. The oscillators are a combination of a counter with a trigonometric or modulo operation.</p>
<p>Turning genomes into programs that map inputs to outputs through operators can be done via <em>genetic programming</em>. </p>
<p><img src="img/agent_graph.png" alt="agent graph"></p>
<h2 id="genetic-programming">Genetic Programming</h2>
<p>Genetic Programming was invented by Nigel Cramer in 1985, but greatly expanded through the work of John Koza. GP evolves programs; it is an example of <strong>metaprogramming</strong>. GP has been used to generate programs to solve hard problems, and to evolve control systems for artificial agents and robots. Karl Sims used GP for his genetic images, and for his evolving virtual creatures.</p>
<ul>
<li><a href="http://dces.essex.ac.uk/staff/rpoli/gp-field-guide/A_Field_Guide_to_Genetic_Programming.pdf">A field guide to GP</a></li>
<li><a href="http://www.cs.montana.edu/~bwall/cs580/introduction_to_gp.pdf">An overview paper</a></li>
<li><a href="http://www.geneticalgorithms.com/Tutorial/index.html">Very short tutorial</a></li>
<li><a href="http://www.pawfal.org/Software/fastbreeder/">An example for audio</a></li>
</ul>
<p>The central concept is that the generating a phenotype is a process of generating <em>code</em>. Populations of generated programs can then be selected and evolved as usual. </p>
<p>Typically the programs for GP follow a tree-like structure. The leaves of the tree are <em>terminals</em> and the branches are <em>functions</em>. Terminals have no inputs; typical terminals are constant numbers and global variable names. Non-terminal functions are specified according to their operator (such as mathematical addition, multiplication, cosine, etc.); they have one or more inputs, which maybe terminals or other functions. This structure is natural to LISP programs:</p>
<pre><code class="lang-lisp">(<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> <span class="hljs-number">6</span> (<span class="hljs-name"><span class="hljs-builtin-name">sin</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> x <span class="hljs-number">2</span>)))
</code></pre>
<p>An yet more elegant way of representing this is as a stack register language, in which values are pushed to a running stack (reading left to right), and operators consume values from this stack. Such languages are sometimes called concatenatative programming languages, since there is no punctuation and they can be split at any point. It looks like this:</p>
<pre><code>x <span class="hljs-number">2</span> + <span class="hljs-built_in">sin</span> <span class="hljs-number">6</span> *
</code></pre><p>The above could be represented in Javascript code as an expression:</p>
<pre><code class="lang-javascript">return <span class="hljs-number">6</span> * (<span class="hljs-name">Math</span>.sin(<span class="hljs-name">x</span> + <span class="hljs-number">2</span>))
</code></pre>
<p>Or it could be represented as a linear series of single-operator instruction statements (which more closely resembles underlying assembly or machine code), each assigning to one temporary register:</p>
<pre><code class="lang-javascript">(<span class="hljs-meta">function</span>() {
    var <span class="hljs-built_in">r1</span> = <span class="hljs-number">2</span><span class="hljs-comment">;</span>
    var <span class="hljs-built_in">r2</span> = x<span class="hljs-comment">;</span>
    var <span class="hljs-built_in">r3</span> = <span class="hljs-built_in">r1</span> + <span class="hljs-built_in">r2</span><span class="hljs-comment">;</span>
    var <span class="hljs-built_in">r4</span> = Math.sin(<span class="hljs-built_in">r3</span>)<span class="hljs-comment">;</span>
    var <span class="hljs-built_in">r5</span> = <span class="hljs-number">6</span><span class="hljs-comment">;</span>
    var <span class="hljs-built_in">r6</span> = <span class="hljs-built_in">r5</span> * <span class="hljs-built_in">r4</span><span class="hljs-comment">;</span>
    return <span class="hljs-built_in">r6</span><span class="hljs-comment">;</span>
})()<span class="hljs-comment">;</span>
</code></pre>
<p>The question is -- how do we turn a genetic code (as a single of numbers or symbols) into one of these programs, and how do we actually execute them? Which is easier to mutate/recombine, which is easier to generate (for the seed population), which is easier to execute in place, etc.?</p>
<!------

Or build fastbreeder?

And finally agents. Here's a work-in-progress template: http://codepen.io/grrrwaaa/pen/obQrZJ?editors=001

### Genetic representation

It may be convenient to represent these programs as a data structure, from which the phenotype code is generated. Doing so makes crossover and mutation much easier. 

For example, integers can be used to specify which function or terminal type a node contains, and which nodes are used as arguments. Tree structures can nest their data directly, while linear structures can refer to nodes by integer register id (or register stack offset). Here is the above program as a list of instruction codes -- which is just a list of numbers!

```javascript
// operator IDs: [ "constant", "global", "add", "mul", "sin" ];
// global IDs: [ "x" ];

var geno = {
    [ 0, 2 ],
    [ 2, 1 ],
    [ 3, 1, 2 ],
    [ 4, 3 ],
    [ 0, 6 ],
    [ 3, 5, 4 ],
}
```

### Initialization 

Generating a seed tree can follow a recursive structure, starting from the root at depth 0, up to a maximum depth ```m```:

- If depth equals ```m``` choose a terminal at random,
- Else select a function or terminal at random.
    - If the node type is a function, choose a random function. Each function has a specific number of children (e.g. the + function has two children); for each child node, repeat the algorithm with depth increased by one.

An alternative algorithm for linear GP, with ```n``` operations:

- Loop from 1 to ```n```:
    - If ```n``` is less than the maximum number of arguments (typically 2 or 3), create a random terminal node.
    - Else create a random terminal or a random function.
        - If the node type is a function, use a randomly selected previous node for each of the function arguments.
- The root (result) node is node ```n```. 

### Variation

For a linearized genotype representation, the genetic mutations and crossover operators are similar to other sequence-based evolutionary systems. 

For tree-like representations it becomes more complex and interesting: Mutations on a tree can include modifcation of instruction arguments, replacement of sub-trees, function mutation, etc. Cross-over can be implemented as swapping sub-trees of parents. 

---

Meta-evolution: the mechanisms of evolution (including development, variation, etc.) are also subject to variation and selection. After all, sexual reproduction had to be *discovered*. It turns out that some parts of our genes have evolved to be far less volatile than others, for good reason. 

Jurgen Schmidhuber proposed using GP to evolve GP (Meta-GP), since things like chromosomes, crossover etc. are themselves phenomena that have evolved. 
-->
	</div>
	<footer>&copy; 2016 Graham Wakefield</footer>
  </body>
</html>