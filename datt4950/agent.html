<!DOCTYPE html>
<html>
  <head>
	<title>Agents</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="DATT4950">DATT4950</a></li>
<li><a href="gallery.html" alt="Gallery">Gallery</a></li>
<li><a href="themes.html" alt="Themes">Themes</a></li>
<li><a href="cellular.html" alt="Cellular Automata">Cellular Automata</a></li>
<li><a href="agent.html" alt="Agents">Agents</a></li>
<li><a href="evo.html" alt="Evolutionary Systems">Evolutionary Systems</a></li>
<li><a href="labs.html" alt="Labs">Labs</a></li>
<li><a href="js.html" alt="JavaScript">JavaScript</a></li>
	</ul>
	</nav>	
	<div id="main">
	<h1 id="agent-based-models-multi-agent-systems">Agent-based models, multi-agent systems</h1>
<p>Agent-based models, or multi-agent systems, attempt to understand how non-trivial organized macro-behavior emerges from typically mobile individuals that sense and respond to a world primarily at a local-level. These individuals are called <strong>agents</strong>. Just like CA, at times, the self-organizing behavior of systems of even relatively simple agents can be unpredictable, complex, and generate new emergent structures of order. Agent-based modeling has applications from microbiology to sociology, as well as video games and computer graphics. As a biological approximation, an agent could refer to anything from an individual protein, virus, cell, bacterium, organism, or deme (a population group). Agent systems also share many features with particle systems, and the two are sometimes conflated.</p>
<h3 id="a-simple-agent">A simple agent</h3>
<p>The first distinction between CA and agent-based systems are that agents are not typically distributed in a grid, and are quite often mobile: a potentially <strong>variable position</strong> in potentially continuous space. The second distinction is that agents may have a number of other <strong>properties</strong> besides position. At the least, a mobile agent may have a <strong>direction</strong> or a <strong>velocity</strong>. </p>
<p>For our purposes, the Javascript <code>Object</code> is a general container for properties, and may serve as the representation of agents:</p>
<pre><code class="lang-javascript">let agent = {
    <span class="hljs-keyword">pos</span>: [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>],  <span class="hljs-comment">// position, x and y components</span>
    vel: [<span class="hljs-number">0.01</span>, <span class="hljs-number">0</span>],  <span class="hljs-comment">// velocity, x and y components</span>
    size: <span class="hljs-number">0.1</span>,
}<span class="hljs-comment">;</span>

function draw(ctx) {
    <span class="hljs-comment">// draw a circle at the agent's position,</span>
    <span class="hljs-comment">// matching the agent's size:</span>
    draw2D.<span class="hljs-keyword">circle</span>(agent.<span class="hljs-keyword">pos</span>, agent.size)<span class="hljs-comment">;</span>
}

function update(dt) {
    <span class="hljs-comment">// apply motion:</span>
    agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">0</span>] += agent.vel[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
    agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">1</span>] += agent.vel[<span class="hljs-number">1</span>]<span class="hljs-comment">;</span>
}
</code></pre>
<p>We could also use a vector object to represent position &amp; velocity, which would offer more useful methods (see the <a href="labs">labs.html</a> page for details on <code>vec2</code>):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> agent = {
    pos: <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),  <span class="hljs-comment">// position, x and y components</span>
    vel: <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.01</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// velocity, x and y components</span>
    size: <span class="hljs-number">0.1</span>,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{
    <span class="hljs-comment">// apply motion:</span>
    agent.pos.add(agent.vel);
}
</code></pre>
<h3 id="boundary-conditions">Boundary conditions</h3>
<p>This agent wanders off the page. As with CA, we can decide how to handle the <strong>boundary conditions</strong> of an agent-based system in a few different ways, including:</p>
<ul>
<li><strong>clamping</strong> agents at the borders; use <code>agent.pos.clip(1)</code></li>
<li><strong>wrapping</strong> agents around opposite borders (making a &#39;toroidal&#39; space); use <code>agent.pos.wrap(1)</code> </li>
<li>other strategies can respond to the <em>condition</em> of being &#39;out of bounds&#39;, using <code>if (agent.pos.oob(1))...</code>, by: </li>
<li><strong>modifying</strong> their velocities/directions to point them back toward the center, etc., or</li>
<li><strong>resetting</strong> agents with a new position, such as at the centre of the world (<code>agent.pos.set(0.5)</code>), or at a random position (<code>agent.pos.set(random(),random())</code>), or some variant, such as random distance from centre of the world (<code>agent.pos.random(random()*0.1).add(0.5)</code>), and possibly also changing other properties</li>
<li>simply letting them die (see below on how to manage variable population sizes)</li>
</ul>
<p>Note that we might also consider different boundary regions -- it doesn&#39;t have to be a square!</p>
<h3 id="random-walks-in-nature">Random walks in nature</h3>
<p>The agent also moves very robotically at present. We can give it some &quot;life&quot; by introducing variations into its motion, suggestive of it making decisions in response to an environment. </p>
<p>The simplest way is to introduce stochastic changes to the velocity in direction and magnitute (speed). For direction, we would typically want to turn up to a certain limit (in radians), with equal chance of clockwise and anticlockwise rotation: <code>agent.vel.rotate((random()-0.5)*turnfactor)</code>. For speed, we can randomize the length of the velocity up to a certain limit: <code>agent.vel.len(random()*maxspeed)</code></p>
<p>The result is a <strong>random walk</strong>. Random walks are a well-established model in mathematics, with a physical interpretation as <a href="https://en.wikipedia.org/wiki/Brownian_motion">Brownian motion</a>. Essentially, for an agent a <strong>random walk</strong> involves small random deviations to steering. This form of movement is widely utilized by nature, whether purposefully or simply through environmental interactions. </p>
<h3 id="multiple-agents">Multiple agents</h3>
<p>A good way of seeing why random walks work is to deploy a <strong>population</strong> of agents, rather than a single one. We can do this by storing our agents in an array:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> agents = [];
<span class="hljs-keyword">let</span> population_size = <span class="hljs-number">24</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;population_size; i++) {
        <span class="hljs-comment">// create a randomized agent:</span>
        <span class="hljs-keyword">let</span> agent = {
            pos: <span class="hljs-keyword">new</span> vec2(random(), random()),
            vel: vec2.random(),
            size: <span class="hljs-number">0.1</span>,
        };
        <span class="hljs-comment">// store in population array:</span>
        agents[i] = agent;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{
    <span class="hljs-comment">// iterate over population:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> agent <span class="hljs-keyword">of</span> agents) {
        <span class="hljs-comment">// update agent as before</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">ctx</span>) </span>{
    <span class="hljs-comment">// iterate over population:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> agent <span class="hljs-keyword">of</span> agents) {
        <span class="hljs-comment">// draw agent as before</span>
    }
}
</code></pre>
<h3 id="the-environmental-field">The environmental field</h3>
<p>The agent however still lives in a void, with no environment to respond to. Even the simplest organisms hve the ability to sense the environment, and direct their motions accordingly; they depend on it for survival. </p>
<p>One of the simplest examples is <strong>chemotaxis</strong>. Chemotaxis is the phenomenon whereby somatic cells, bacteria, and other single-cell or multicellular organisms direct their movements according to certain chemicals in their environment. This is important for bacteria to find food (for example, glucose) by swimming towards the highest <strong>concentration</strong> of food molecules, or to flee from poisons (for example, phenol). In multicellular organisms, chemotaxis is critical to early development (e.g. movement of sperm towards the egg during fertilization) and subsequent phases of development (e.g. migration of neurons or lymphocytes) as well as in normal function. <a href="https://en.wikipedia.org/wiki/Chemotaxis">wikipedia</a></p>
<p>Sensing a <strong>concentration</strong> is rather like smell: the feature being detected is not a solid object with a distinct boundary, but is <em>diffuse</em>: it seems instead to occupy all parts of space to varying degrees. We model such kinds of spatial properties as <em>fields</em>, such as density fields, probability fields, magnetic fields, etc. Fields occupy all space but in different intensities. But since our simulations are limited in memory, we <em>simulate</em> such continuous fields with discrete approximations, such as grids. Thus we can re-use the <code>field2D</code> to represent enviornmental features for agents to sense. </p>
<p>The choice of <strong>environment</strong> agents will respond is just as important as the design of agents themselves, including both its <strong>initial state</strong> and its <strong>continuous processes</strong>. If the field is entirely homogenous, in which there are no spatial variations, there is nothing significant to sense. On the other hand, if the field is too noisy, it can be too difficult to make sense of. How can we make a better environment?</p>
<p>Perhaps it is helpful to think of the environment as a landscape, with mountain tops where the intensity is high, and valleys where the intensity is low. Now a homongenous landscape is like a flat plain -- no place is better than any other. But a noisy landscape is like a city block designed by a madman -- difficult to do anything but get lost. What makes an interesting landscape to explore &amp; make sense of? Perhaps one that has an interesting distribution of hills and valleys; where height (intensity) tends to be more similar at shorter distances but tends to be more different at larger distances. </p>
<p>Here&#39;s a single central mountain, by computing the distance from the centre:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> dim = <span class="hljs-number">256</span>;
<span class="hljs-keyword">let</span> sugar = <span class="hljs-keyword">new</span> field2D(dim);
<span class="hljs-keyword">let</span> center = <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);

sugar.set(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-comment">// convert x, y in to 0..1 range:</span>
    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> vec2(x / dim, y / dim);
    <span class="hljs-comment">// get distance from center:</span>
    <span class="hljs-keyword">var</span> d = p.distance(center);
    <span class="hljs-comment">// make concentration high at center, lower with increasing distance:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - d;
})
</code></pre>
<p>Or, for a more interesting and variegated landscape, we can start from uniform noise, and then smoothen it out:</p>
<pre><code class="lang-javascript">//<span class="hljs-built_in"> fill </span>with uniform noise
sugar.set(function(x, y) {<span class="hljs-built_in"> return </span>random(); });
// smoothen it out by<span class="hljs-built_in"> long-range </span>diffusion:
sugar.diffuse(sugar.clone(), sugar.width, 100);
// make it vary between 0<span class="hljs-built_in"> and </span>1:
sugar.normalize();
</code></pre>
<p>Or, we could design a CA to generate an interesting landscape, such as using a stochastic Monte Carlo process that prefers making neigbhour cells more similar, starting from a field of noise.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// fill with uniform noise</span>
  sugar.set(function(x, y) { <span class="hljs-keyword">return</span> random()<span class="hljs-comment">; });</span>
  <span class="hljs-comment">// run a stochastic CA for a while:</span>
  <span class="hljs-keyword">for</span> (let i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;dim*dim*40; i++) {</span>
    <span class="hljs-comment">// pick a random cell:</span>
    let x0 = random(<span class="hljs-keyword">dim</span>)<span class="hljs-comment">;</span>
    let y0 = random(<span class="hljs-keyword">dim</span>)<span class="hljs-comment">;</span>
    let v0 = sugar.get(x0, y0)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a random neighbor:</span>
    let x1 = x0 + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    let y1 = y0 + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    let v1 = sugar.get(x1, y1)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// average them:</span>
    let v2 = (v0 + v1)*<span class="hljs-number">0.5</span><span class="hljs-comment">;</span>
    <span class="hljs-comment">// and update cell with this new value</span>
    sugar.set(v2, x0, y0)<span class="hljs-comment">;</span>
  }
  <span class="hljs-comment">// make it vary between 0 and 1:</span>
  sugar.normalize()<span class="hljs-comment">;</span>
</code></pre>
<h3 id="sensing-the-field">Sensing the field</h3>
<p>Sensing a field by &quot;smell&quot; is as simple as sampling the field&#39;s value at the agent&#39;s location. We can compute the nearest cell index to the agent, and then get the value:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// scale position (0..1) to field cell width</span>
<span class="hljs-comment">// and use Math.floor to round this to a whole number:</span>
let x = Math.floor(agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">0</span>] * sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
let y = Math.floor(agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">1</span>] * sugar.height)<span class="hljs-comment">;</span>
<span class="hljs-comment">// get field value at this cell:</span>
agent.sense = sugar.get(x, y)<span class="hljs-comment">;</span>
</code></pre>
<p>This is fine so long as we think of the environment as being really made up of discrete blocks in a grid. But in many cases, our grid-based field is only a <em>discrete approximation</em> of a continuous field. In that case, sensing single discrete cells breaks the approximation. What we really want is an approximate value taken between <em>all</em> the nearest cells. We can do this by <em>bilinear interpolation</em> between the four nearest cells, weighted according to which ones are closer or further from the specific agent position. This involves a lengthier bit of code, so the <code>field2D</code> object provides a convenient method for us:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// get an interpolated value from the field, </span>
<span class="hljs-comment">// using the nearest four cells to the agent's position:</span>
agent.sense = sugar.sample(agent.<span class="hljs-keyword">pos</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>We can test whether this is working by for example setting the hue of an agent before drawing:</p>
<pre><code class="lang-javascript">draw2D.<span class="hljs-keyword">color</span> = hsl(agent.sense)<span class="hljs-comment">;</span>
</code></pre>
<h3 id="responding-to-the-field">Responding to the field</h3>
<p>Once we have a sense, how should we respond? Here we need to equip our agent with some capabilities of taking <strong>action</strong>, as well as with a <strong>decision-making</strong> capability, sometimes known as <strong>action selection</strong>, that uses the input of sense to map to the output of action, in order to achieve a desired result. (The random walker&#39;s action was to change velocity, while decision-making was a simple mapping of a random number.)</p>
<p>When we look at microbiology we can find some remarkably simple action &amp; decision-making mechanisms to achieve effective goal satisfaction. Let&#39;s look at chemotaxis again. For example, the E. Coli bacterium&#39;s <em>goal</em> is to find the highest sugar concentration. But it has no eyes or ears to sense at a distance, it can only sense the local sugar concentration at its current location. It has no sense of direction, nor any internal &quot;map&quot;. Its range of actions are limited to twisting its flagella, resulting in just two modes of <em>locomotion</em>: </p>
<ul>
<li>Move forward more or less straight</li>
<li>Tumble about fairly randomly</li>
</ul>
<iframe width="720" height="540" src="https://www.youtube.com/embed/ZV5CfOkV6ek?rel=0" frameborder="0" allowfullscreen></iframe>

<p>We can certainly model these two modes of locomotion in an agent, by varing the factors of our random walker:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// tumbling behaviour:</span>
agent.vel.<span class="hljs-built_in">rotate</span>((<span class="hljs-built_in">random</span>()<span class="hljs-number">-0.5</span>)*<span class="hljs-number">2.0</span>).len(<span class="hljs-number">0.0005</span>);

<span class="hljs-comment">// swimming behaviour:</span>
agent.vel.<span class="hljs-built_in">rotate</span>((<span class="hljs-built_in">random</span>()<span class="hljs-number">-0.5</span>)*<span class="hljs-number">0.1</span>).len(<span class="hljs-number">0.005</span>);
</code></pre>
<p>But how does this solve the problem? </p>
<hr>
<p>E. Coli uses a very simple chemical <strong>memory</strong> to detect whether the concentration at the current moment is better, worse, or not much different to how it was a few moments ago. That is, it detects the differential experienced, or gradient traversed. Knowing whether things are getting better or worse is used to select between the swimming or tumbling patterns. With just a few tuning parameters, the method can lead to a very rapid success. </p>
<p>So all we need is to compare the sugar concentration with the agent&#39;s memory (a stored member variable) of the concentration on the last time step, and choose the behaviour accordingly (and of course, store our sensed value in memory for the next update).</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// sense field here</span>
<span class="hljs-built_in">agent</span>.sense = sugar.sample(<span class="hljs-built_in">agent</span>.pos);
<span class="hljs-comment">// is life getting worse?</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">agent</span>.sense &lt; <span class="hljs-built_in">agent</span>.memory) {
    <span class="hljs-comment">// tumbling behaviour:</span>
    <span class="hljs-built_in">agent</span>.vel.rotate((<span class="hljs-built_in">random</span>()-<span class="hljs-number">0.5</span>)*tumbleturn).len(<span class="hljs-built_in">agent</span>.<span class="hljs-built_in">size</span> * tumblespeed);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// swimming behaviour:</span>
    <span class="hljs-built_in">agent</span>.vel.rotate((<span class="hljs-built_in">random</span>()-<span class="hljs-number">0.5</span>)*swimturn).len(<span class="hljs-built_in">agent</span>.<span class="hljs-built_in">size</span> *  swimspeed);
}
<span class="hljs-comment">// remember this:</span>
<span class="hljs-built_in">agent</span>.memory = <span class="hljs-built_in">agent</span>.sense;
</code></pre>
<p>Note that this method works when the variations of sugar concentration in the environment are fairly smooth, which is generally true for an environment in which concentrations diffuse. Try again with noisy or homogenous environments, and see how well the agent fares.</p>
<h3 id="continuations">Continuations</h3>
<p>So far, our sugar field is static. It would be nice to see what a continuously dynamic field offers. </p>
<p>For example, we could let the mouse add more sugar to the space, and watch it gradually diffuse away. Adding sugar in response to the mouse is fairly easy, by making use of the <code>deposit</code> method of field2D. This method accumulates into the field at a point coordinate, adding to its existing values. Note that the coordinate is in the normalized 0..1 range, and that it will spread the value over the nearest four cells:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouse</span><span class="hljs-params">(e, pt)</span> </span>{
    <span class="hljs-comment">// add one unit of sugar at the location of the mouse:</span>
    sugar.deposit(<span class="hljs-number">1</span>, pt);
}
</code></pre>
<p>We could also remove the need of human input by creating another kind of agent, as the &quot;source&quot;, randomly wandering the space and depositing sugar as it goes. </p>
<p>So far this isn&#39;t completely effective to attract agents, as there can be large spatial discontinuities. If agents happen to be on part of a drawn path, they might follow it, but otherwise they are unlikely to find it. </p>
<p>To create a smoother gradient, we must diffuse the field continuously. To add continuous dynamics, we need to add field processing to our <code>update()</code> routine. And since the <code>diffuse()</code> method requires a distinct source field, we&#39;ll need to double buffer like before:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> sugar_past = sugar.<span class="hljs-keyword">clone</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// swap fields:</span>
    <span class="hljs-keyword">let</span> tmp = sugar_past;
    sugar_past = sugar;
    sugar = tmp;
    <span class="hljs-comment">// diffuse it</span>
    sugar.diffuse(sugar_past, <span class="hljs-number">0.1</span>);

    <span class="hljs-comment">//... update agents as before</span>
}
</code></pre>
<p>Now the agents are able to find the areas of sugar more easily -- and might even show something like trail-following.</p>
<p>We might also notice that even when the sugar is quite dissipated, the agents can still find the strongest concentrations. If we don&#39;t find this realistic, one thing we might consider adding is a low level of background randomness. The rationale is that even if sensing is perfectly accurate, small fluctuations in the world (such as due to the Brownian motion of water and sugar molecules) make it impossible to discern very small differences. The randomness added must be signed noise, balanced around zero such that overall the total intensity is statistically preserved. Note that the amplitude of this noise will have to be extremely high if it is applied <em>before</em> the diffusion, or very low if applied <em>after</em> diffusion. The effective results are also quite different.</p>
<pre><code class="lang-javascript">    <span class="hljs-comment">// applied after sugar.diffuse:</span>
    <span class="hljs-comment">// use field2D.map() to modify a cell value</span>
    <span class="hljs-comment">// adding a small random deviation</span>
    <span class="hljs-comment">// whose average is zero</span>
    sugar.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{ 
        <span class="hljs-keyword">return</span> v + <span class="hljs-number">0.01</span>*(random() - <span class="hljs-number">0.5</span>);
    });
</code></pre>
<p>Still, the sugar just seems to accumulate over time, and the more we draw, the more the screen tends to grey. This is because our diffuse() method spreads intensity out, but does not change the total quantity. We need some other process to reduce this total quantity to make a balance. One way to do that is to add a very weak overall decay to the field -- as if some particles of sugar occasionally evaporate:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// in update():</span>
    sugar.mul<span class="hljs-comment">(0.99)</span>;
</code></pre>
<p>Of course, our agents aren&#39;t just looking for sugar to show it to us -- they want to eat it! We can also add the effect of this on the environment by <em>removing</em> intensity from the field by each agent. We can do this by calling the <code>field2D.deposit()</code> method with a negative argument (i.e. a debit!):</p>
<pre><code class="lang-javascript">    <span class="hljs-comment">// get the sugar level at this location:</span>
    var sense = Math.max(sugar.sample(a.<span class="hljs-keyword">pos</span>), <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// update the field to show that we removed sugar here:</span>
    sugar.deposit(-sense, agent.<span class="hljs-keyword">pos</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Note however this might lead to some locations getting negative concentrations -- a physical impossibility? We could fix this by clamping the field values as another step:</p>
<pre><code class="lang-javascript">    sugar.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{ 
        <span class="hljs-keyword">return</span> clamp(v, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    });
</code></pre>
<blockquote>
<p><strong>Aside</strong>: A very different alternative to diffusion, scaling, adding noise, clamping etc. is to use something closer to an asynchronous CA, in continuous process, rather as we did before for field initialization. This makes a more challenging, but more interesting, dynamic landscape for the agents to navigate:</p>
</blockquote>
<pre><code class="lang-javascript">  <span class="hljs-comment">// some swaps:</span>
  <span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;10000; i++) {</span>
    <span class="hljs-comment">// pick a point at random</span>
    var x = random(sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
    var y = random(sugar.height)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a neighbour</span>
    var x1 = x + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    var y1 = y + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    <span class="hljs-comment">// get the values</span>
    var a = sugar.get(x, y)<span class="hljs-comment">;</span>
    var b = sugar.get(x1, y1)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a random interpolation factor</span>
    var t = <span class="hljs-number">0.5</span>*random()<span class="hljs-comment">;</span>
    <span class="hljs-comment">// blend a and b into each other accordingly</span>
    var a1 = a + t*(b-a)<span class="hljs-comment">;</span>
    var b1 = b + t*(a-b)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// write these values back to the field</span>
    sugar.set(a1, x, y)<span class="hljs-comment">;</span>
    sugar.set(b1, x1, y1)<span class="hljs-comment">;</span>
  }
  <span class="hljs-comment">// some removals:</span>
  <span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;100; i++) {</span>
    var x = random(sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
    var y = random(sugar.height)<span class="hljs-comment">;</span>
    sugar.set(<span class="hljs-number">0</span>, x, y)<span class="hljs-comment">;</span>
  }
</code></pre>
<blockquote>
<p>Obviously there&#39;s a hint here of how it might be interesting to pair our agents with some other CAs for field processes... perhaps the Forest Fire model, for example.</p>
</blockquote>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="QYjpKb" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="2019 DATT4950 week 4: Agents">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/QYjpKb/">
  2019 DATT4950 week 4: Agents</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h2 id="the-model-so-far-">The model so far:</h2>
<p>An agent-based system can comprise:</p>
<ul>
<li>a <strong>population</strong> of agents, each with:<ul>
<li><strong>position</strong> </li>
<li><strong>mobility</strong>, e.g. as velocity</li>
<li>other <strong>properties</strong> such as size, colour, etc.</li>
<li><strong>decision-making</strong> that may relate the above with:<ul>
<li><strong>input senses</strong> such as field smell</li>
<li><strong>output actions</strong> such as changes to velocity</li>
<li><strong>memory</strong></li>
</ul>
</li>
</ul>
</li>
<li>an <strong>environment</strong>, with:<ul>
<li><strong>boundary conditions</strong></li>
<li><strong>initial conditions</strong></li>
<li><strong>continuous processes</strong> including addition, removal, diffusion, limiting, stochastics, etc.</li>
</ul>
</li>
</ul>
<!-- 

All of 'what is an agent' up to Reynolds flocking.

[See the random walker example here](http://codepen.io/grrrwaaa/pen/mVBBPQ?editors=001). Rather than simple deviations to the current heading, this follows Reynold's method to generate headings based on deviations of an ideal point just ahead of the agent, which is more parametrically defined.

[And here are many walkers](http://codepen.io/grrrwaaa/pen/YwEbRO?editors=001) -- to help demonstrate how to support populations, and how quickly random walkers can cover a terrain. This is on reason why random walks feature in many foraging behaviours in nature.


> A variety of other *taxes* worth exploring can be found on the [wikipedia page](http://en.wikipedia.org/wiki/Taxis#Aerotaxis). Note how chemotaxis (and other taxes) can be divided into positive (attractive) and negative (repulsive) characters, just like forces (directly seen in steering forces). This is closely related to the concepts of positive and negative feedback and the explorations of cybernetics.

Continue at stigmergy?

Or consider the other kind of enviornment: each other?

Or continue at Birth & Death?



![Fish school](http://underthecblog.files.wordpress.com/2014/02/fishschool.gif)

Some of the most beautiful, fascinating or strange phenomena of nature can be understood as emerging from the behaviors of interacting agents. Widely acknowledged examples include the murmuration of birds (or swarming insects, schools of fish), and the societal 'superorganisms' of ant colonies. We have come to understand that despite the obvious organization that we see at the macro-scale, there is no hierarchical center of coordination, but rather the whole emerges from simple interactions at local levels. These have been suggested as examples of emergence, or of self-organization. Which is to say, the whole is greater than a naive sum of its parts. 
-->
<hr>
<h2 id="path-following">Path following</h2>
<p>Another simple form of chemotactic behavior is to align movement along given &quot;trails&quot; -- paths of more intense chemical markers, such as the pheromone trails laid down by ants. Again, this can be achieved by a relatively simple mechanism. In this case, agents need two sensors, both ahead of the agent (to draw movement forward) and to the left and right of the agent (to discriminate which direction is better to turn). </p>
<p>Let&#39;s call these sensors &quot;antennae&quot;. A bit of math is needed to compute where each antenna is located in the world. Starting from a basic vector representing the antenna relative to tha agent, we can then scale, rotate, and translate the location, resulting in a location relative to the world:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// antenna is 50% forward and 50% to the left of the agent:</span>
let antennaleft = <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);
<span class="hljs-comment">// compute what this is as a world location:</span>
antennaleft
    .mul(agent.<span class="hljs-built_in">size</span>) <span class="hljs-comment">// scale to agent size</span>
    .<span class="hljs-built_in">rotate</span>(agent.vel.angle()) <span class="hljs-comment">// rotate to agent direction</span>
    .<span class="hljs-built_in">add</span>(agent.pos); <span class="hljs-comment">// move to agent location</span>
</code></pre>
<p>With this, and of course also <code>antennaright</code>, we can sample the environmental field at both locations to get two sensor values:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">smellleft</span> = sugar.sample(antennaleft);
<span class="hljs-keyword">let</span> <span class="hljs-attr">smellright</span> = sugar.sample(antennaright);
</code></pre>
<p>Now the decision-making can respond to these values. We might consider which direction has a better smell (left or right), we might consider the difference between the smells, we might consider the total of the smells too, in order to determine which way to turn, and how much to turn:</p>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="qgPZBK" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="line following agents">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/qgPZBK/">
  line following agents</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>From here it is relatively trivial to let the agents also <em>create</em> the trails, as well as following them:</p>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="pGWbWx" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="trailblazing agents">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/pGWbWx/">
  trailblazing agents</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<hr>
<h2 id="neighbours">Neighbours</h2>
<p>Agents might also be sensitive to each other directly -- as well as, or instead of, through fields. Since agents are mobile, the set of agents that are close neighbours to another can change over time. We thus need to add routines to maintain lists of near-neighbours on each frame.  </p>
<p>The simplest method is to compare each agent against each other and check the relative distance. (This method can be refined in many ways). </p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> visible<span class="hljs-number">_</span>range = <span class="hljs-number">0.1</span>;
<span class="hljs-comment">// find neighbours:</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> agents) {
    <span class="hljs-comment">// clear the neighbour list:</span>
    a.neighbours = [];
    <span class="hljs-comment">// consider all possible agents:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b <span class="hljs-keyword">of</span> agents) {
        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// don't count self</span>
        <span class="hljs-comment">// consider if we are close enough:</span>
        <span class="hljs-keyword">let</span> dist = vec<span class="hljs-number">2</span>.distance(a.pos, b.pos) - a.size - b.size;
        <span class="hljs-keyword">if</span> (dist &lt; visible<span class="hljs-number">_</span>range) {
            <span class="hljs-comment">// add to list:</span>
            a.neighbours.push(b);
        }      
    }
}
</code></pre>
<p>Notice how:</p>
<ul>
<li>we reset the <code>a.neighbours</code> list on each frame -- otherwise it would grow infinitely!  </li>
<li>we make sure not to count ourselves (<code>if (a == b) continue</code>)</li>
<li>we take into account the sizes of agents in computing the distance, so that it is distance between their edges rather than distance between their centres</li>
</ul>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="VgrYXr" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="neighbours">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/VgrYXr/">
  neighbours</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<hr>
<h2 id="death-note-adding-removing-agents-from-an-array">Death Note: adding/removing agents from an array</h2>
<p>If we want to extend our model to support death, such as being eaten by a predator, infected by a disease, starvation, poison, fire, etc., we will need a way to remove items from our array of agents. Assuming that we can mark death by some property (such as <code>a.dead = true</code>), you might expect to remove it from the <code>agents</code> array as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">agents</span>[n].dead) {
    <span class="hljs-built_in">agents</span>.splice(n, <span class="hljs-number">1</span>);
}
</code></pre>
<blockquote>
<p>(Note that <code>delete agents[n]</code> won&#39;t work at all, it doesn&#39;t reshuffle the array to accommodate the gap, it just leaves the gap right there.)</p>
</blockquote>
<p>Similarly, if an agent gives birth, you might expect to add the child as follows:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">if</span> (child) {
    agents.<span class="hljs-keyword">push</span>(child);
}
</code></pre>
<p>But in general, <strong>adding to or removing from an array is not safe while iterating the array</strong>, which is almost certainly the time that you would want to do it. The reason is that you may end up skipping an item, or trying to iterate over an item that no longer exists, or visiting an item twice, because the exact positions of items and the array length have changed. This is one of the classic problems commonly encountered in many imperative programming languages (e.g. C++ too). </p>
<p>Here are two suggested solutions:</p>
<p><strong>Iterate backwards</strong></p>
<p>It is safe to splice and push while iterating backwards, because reshuffling an array only affects later items:</p>
<pre><code class="lang-javascript">let i = agents.<span class="hljs-keyword">length</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">while</span> (i--) {
    let a = agents[i]<span class="hljs-comment">;</span>

    <span class="hljs-comment">//.. do stuff, </span>
    <span class="hljs-comment">// possibly setting dead = true </span>
    <span class="hljs-comment">// or creating a chil</span>

    <span class="hljs-keyword">if</span> (dead) {
        <span class="hljs-comment">// remove safely:</span>
        agents.splice(i, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child) {
        <span class="hljs-comment">// add a child:</span>
        agents.push(child)<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>Note that in this case, new births will not be visited until the next frame. This is probably what you want, since otherwise you might end up creating an infinite loop!</p>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="xMPbqE" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="birth and death">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/xMPbqE/">
  birth and death</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>Double-buffer</strong></p>
<p>Rather than modifying the array in-place, we build a new array on each iteration, and replace the original when done. This has the advantage of working with for-of loops:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// create new array for the next frame's population:</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">new</span><span class="hljs-number">_p</span>opulation = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> agents) {

    <span class="hljs-comment">//.. do stuff, </span>
    <span class="hljs-comment">// possibly setting dead = true </span>
    <span class="hljs-comment">// or creating a child</span>

    <span class="hljs-comment">// preserve only living agents:</span>
    <span class="hljs-keyword">if</span> (!dead) <span class="hljs-keyword">new</span><span class="hljs-number">_p</span>opulation.push(a);
    <span class="hljs-comment">// add a child?</span>
    <span class="hljs-keyword">if</span> (child) <span class="hljs-keyword">new</span><span class="hljs-number">_p</span>opulation.push(child);        
}
<span class="hljs-comment">// replace original</span>
agents = <span class="hljs-keyword">new</span><span class="hljs-number">_p</span>opulation;
</code></pre>
<p>Note that new children are added to <code>newagents</code>, ensuring they are visited next frame. If we added them to <code>agents</code>, they would also be included in the iterating for loop on the current frame, which could potentially lead to an infinite loop. </p>
<p><p class="codepen" data-height="300" data-theme-id="18447" data-default-tab="js,result" data-user="grrrwaaa" data-slug-hash="RvjPMm" data-preview="true" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="birth and death">
  <span>See the Pen <a href="https://codepen.io/grrrwaaa/pen/RvjPMm/">
  birth and death</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h2 id="practical-limits-of-population-sizes">Practical limits of population sizes</h2>
<p>Clearly if a population ever drops to zero, we will never see any organisms again. This may be problematic for an ongoing exhibition! Methods to overcome this include preventing death of the last (few?) creatures, or introducing new randomly seeded organisms (perhaps out of view) at low population sizes. </p>
<p>At the other end, a population that grows excessively large can slow down the simulation, perhaps even crash it. Again, this is problematic for an ongoing exhibition. It may be necessary to set an absolute population size limit (preventing new agents from being added at this point). </p>
<p>It would be preferable if a simulation didn&#39;t hit these externally-imposed limits; or at least, not very often. It would be preferable if some kind of <em>endogenous</em> forces, some processes that are part of the world itself, automatically avoid these events. Perhaps an overly-large population is sporadically decimated by extreme weather events, or a mass infection, for example. Whatever the solution, it involves macroscopic behaviour (population size) affecting microscopic behaviour (individual agents reproduction/death).</p>
<h3 id="energy-dynamics">Energy dynamics</h3>
<p>If we are careful to apply an energetic cost to every agent activity, and energetic gain through eating/respiration/metabolism, we can count the total energy balance over the entire system on each frame. We can then apply that energy deficit/surplus back into the system in an environmental way, ensuring that the total energy of the system remains constant. </p>
<ul>
<li>Each agent needs a representation of its currently available potential energy. </li>
<li>Each activity of an agent: metabolism, moving, eating, growing, reproducing, etc., has some energetic cost that reduces the agent&#39;s store.</li>
<li>Certain activities (eating, respiring, etc.) may increase the he agent&#39;s energy store.</li>
<li>Total energy in a population can be computed by summing the store of each member agent</li>
</ul>
<p>This is the population&#39;s <strong>total energy expenditure</strong> (which incidentally may also be a useful indicator of the liveliness of a system).</p>
<ul>
<li>Total energy in the environment (such as a &#39;sugar&#39; field2D) by adding up the total in each field cell (by <code>sugar.sum()</code>)</li>
</ul>
<p>Adding together the population and environmental totals gives is the measure of the <strong>total available energy</strong> in the world. The goal is for this total available energy to remain fairly constant, at an <strong>ideal energetic carrying capacity</strong>. Compute the difference of <code>available - ideal</code>: if there is surplus, remove it from the environment; if there is deficit, distribute new energy to the environment. So, if this total energy level is below the chosen carrying capacity for the world, we can then introduce energy back in, to ensure that the whole system doesn&#39;t wind down to zero. Re-introducing energy could be done by distributing it somewhat randomly in the space, or by probabilistic expansion of a current growth area, etc. Similarly, if it somehow exceeds the capacity, it can be randomly or gradually removed from the environment. </p>
<p>Energy dynamics should help keep a population size in reasonable ranges, however it may still be necessary to also implement the hard limit cases.</p>
<!--
[Example](http://codepen.io/grrrwaaa/pen/PZxrbo?editors=0010)

[And here's that example combined with the chemotaxis model](http://codepen.io/grrrwaaa/pen/QKXaGb?editors=0010)
-->
	</div>
	<footer>&copy; 2018 Graham Wakefield</footer>
  </body>
</html>