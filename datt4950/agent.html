<!DOCTYPE html>
<html>
  <head>
	<title>Agent-Based Systems</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="DATT4950">DATT4950</a></li>
<li><a href="gallery.html" alt="Gallery">Gallery</a></li>
<li><a href="themes.html" alt="Themes">Themes</a></li>
<li><a href="cellular.html" alt="Cellular Systems">Cellular Systems</a></li>
<li><a href="agent.html" alt="Agent-Based Systems">Agent-Based Systems</a></li>
<li><a href="labs.html" alt="Labs">Labs</a></li>
<li><a href="js.html" alt="JavaScript">JavaScript</a></li>
	</ul>
	</nav>	
	<div id="main">
	<h1 id="agent-based-models-multi-agent-systems">Agent-based models, multi-agent systems</h1>
<p>Agent-based models, or multi-agent systems, attempt to understand how non-trivial organized macro-behavior emerges from typically mobile individuals that sense and respond to a world primarily at a local-level. These individuals are called <strong>agents</strong>. Just like CA, at times, the self-organizing behavior of systems of even relatively simple agents can be unpredictable, complex, and generate new emergent structures of order. Agent-based modeling has applications from microbiology to sociology, as well as video games and computer graphics. As a biological approximation, an agent could refer to anything from an individual protein, virus, cell, bacterium, organism, or deme (a population group). Agent systems also share many features with particle systems, and the two are sometimes conflated.</p>
<h3 id="a-simple-agent">A simple agent</h3>
<p>The first distinction between CA and agent-based systems are that agents are not typically distributed in a grid, and are quite often mobile: a potentially <strong>variable position</strong> in potentially continuous space. The second distinction is that agents may have a number of other <strong>properties</strong> besides position. At the least, a mobile agent may have a <strong>direction</strong> or a <strong>velocity</strong>. </p>
<p>For our purposes, the Javascript <code>Object</code> is a general container for properties, and may serve as the representation of agents:</p>
<pre><code class="lang-javascript">let agent = {
    <span class="hljs-keyword">pos</span>: [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>],  <span class="hljs-comment">// position, x and y components</span>
    vel: [<span class="hljs-number">0.01</span>, <span class="hljs-number">0</span>],  <span class="hljs-comment">// velocity, x and y components</span>
    size: <span class="hljs-number">0.1</span>,
}<span class="hljs-comment">;</span>

function draw(ctx) {
    <span class="hljs-comment">// draw a circle at the agent's position,</span>
    <span class="hljs-comment">// matching the agent's size:</span>
    draw2D.<span class="hljs-keyword">circle</span>(agent.<span class="hljs-keyword">pos</span>, agent.size)<span class="hljs-comment">;</span>
}

function update(dt) {
    <span class="hljs-comment">// apply motion:</span>
    agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">0</span>] += agent.vel[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span>
    agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">1</span>] += agent.vel[<span class="hljs-number">1</span>]<span class="hljs-comment">;</span>
}
</code></pre>
<p>We could also use a vector object to represent position &amp; velocity, which would offer more useful methods (see the <a href="labs">labs.html</a> page for details on <code>vec2</code>):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> agent = {
    pos: <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>),  <span class="hljs-comment">// position, x and y components</span>
    vel: <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.01</span>, <span class="hljs-number">0</span>),  <span class="hljs-comment">// velocity, x and y components</span>
    size: <span class="hljs-number">0.1</span>,
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{
    <span class="hljs-comment">// apply motion:</span>
    agent.pos.add(agent.vel);
}
</code></pre>
<h3 id="boundary-conditions">Boundary conditions</h3>
<p>This agent wanders off the page. As with CA, we can decide how to handle the <strong>boundary conditions</strong> of an agent-based system in a few different ways, including:</p>
<ul>
<li><strong>clamping</strong> agents at the borders; use <code>agent.pos.clip(1)</code></li>
<li><strong>wrapping</strong> agents around opposite borders (making a &#39;toroidal&#39; space); use <code>agent.pos.wrap(1)</code> </li>
<li>other strategies can respond to the <em>condition</em> of being &#39;out of bounds&#39;, using <code>if (agent.pos.oob(1))...</code>, by: </li>
<li><strong>modifying</strong> their velocities/directions to point them back toward the center, etc., or</li>
<li><strong>resetting</strong> agents with a new position, such as at the centre of the world (<code>agent.pos.set(0.5)</code>), or at a random position (<code>agent.pos.set(random(),random())</code>), or some variant, such as random distance from centre of the world (<code>agent.pos.random(random()*0.1).add(0.5)</code>), and possibly also changing other properties</li>
<li>simply letting them die (see below on how to manage variable population sizes)</li>
</ul>
<p>Note that we might also consider different boundary regions -- it doesn&#39;t have to be a square!</p>
<h3 id="random-walks-in-nature">Random walks in nature</h3>
<p>The agent also moves very robotically at present. We can give it some &quot;life&quot; by introducing variations into its motion, suggestive of it making decisions in response to an environment. </p>
<p>The simplest way is to introduce stochastic changes to the velocity in direction and magnitute (speed). For direction, we would typically want to turn up to a certain limit (in radians), with equal chance of clockwise and anticlockwise rotation: <code>agent.vel.rotate((random()-0.5)*turnfactor)</code>. For speed, we can randomize the length of the velocity up to a certain limit: <code>agent.vel.len(random()*maxspeed)</code></p>
<p>The result is a <strong>random walk</strong>. Random walks are a well-established model in mathematics, with a physical interpretation as <a href="https://en.wikipedia.org/wiki/Brownian_motion">Brownian motion</a>. Essentially, for an agent a <strong>random walk</strong> involves small random deviations to steering. This form of movement is widely utilized by nature, whether purposefully or simply through environmental interactions. </p>
<h3 id="multiple-agents">Multiple agents</h3>
<p>A good way of seeing why random walks work is to deploy a <strong>population</strong> of agents, rather than a single one. We can do this by storing our agents in an array:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> agents = [];
<span class="hljs-keyword">let</span> population_size = <span class="hljs-number">24</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;population_size; i++) {
        <span class="hljs-comment">// create a randomized agent:</span>
        <span class="hljs-keyword">let</span> agent = {
            pos: <span class="hljs-keyword">new</span> vec2(random(), random()),
            vel: vec2.random(),
            size: <span class="hljs-number">0.1</span>,
        };
        <span class="hljs-comment">// store in population array:</span>
        agents[i] = agent;
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{
    <span class="hljs-comment">// iterate over population:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> agent <span class="hljs-keyword">of</span> agents) {
        <span class="hljs-comment">// update agent as before</span>
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">ctx</span>) </span>{
    <span class="hljs-comment">// iterate over population:</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> agent <span class="hljs-keyword">of</span> agents) {
        <span class="hljs-comment">// draw agent as before</span>
    }
}
</code></pre>
<h3 id="the-environmental-field">The environmental field</h3>
<p>The agent however still lives in a void, with no environment to respond to. Even the simplest organisms hve the ability to sense the environment, and direct their motions accordingly; they depend on it for survival. </p>
<p>One of the simplest examples is <strong>chemotaxis</strong>. Chemotaxis is the phenomenon whereby somatic cells, bacteria, and other single-cell or multicellular organisms direct their movements according to certain chemicals in their environment. This is important for bacteria to find food (for example, glucose) by swimming towards the highest <strong>concentration</strong> of food molecules, or to flee from poisons (for example, phenol). In multicellular organisms, chemotaxis is critical to early development (e.g. movement of sperm towards the egg during fertilization) and subsequent phases of development (e.g. migration of neurons or lymphocytes) as well as in normal function. <a href="https://en.wikipedia.org/wiki/Chemotaxis">wikipedia</a></p>
<p>Sensing a <strong>concentration</strong> is rather like smell: the feature being detected is not a solid object with a distinct boundary, but is <em>diffuse</em>: it seems instead to occupy all parts of space to varying degrees. We model such kinds of spatial properties as <em>fields</em>, such as density fields, probability fields, magnetic fields, etc. Fields occupy all space but in different intensities. But since our simulations are limited in memory, we <em>simulate</em> such continuous fields with discrete approximations, such as grids. Thus we can re-use the <code>field2D</code> to represent enviornmental features for agents to sense. </p>
<p>The choice of <strong>environment</strong> agents will respond is just as important as the design of agents themselves, including both its <strong>initial state</strong> and its <strong>continuous processes</strong>. If the field is entirely homogenous, in which there are no spatial variations, there is nothing significant to sense. On the other hand, if the field is too noisy, it can be too difficult to make sense of. How can we make a better environment?</p>
<p>Perhaps it is helpful to think of the environment as a landscape, with mountain tops where the intensity is high, and valleys where the intensity is low. Now a homongenous landscape is like a flat plain -- no place is better than any other. But a noisy landscape is like a city block designed by a madman -- difficult to do anything but get lost. What makes an interesting landscape to explore &amp; make sense of? Perhaps one that has an interesting distribution of hills and valleys; where height (intensity) tends to be more similar at shorter distances but tends to be more different at larger distances. </p>
<p>Here&#39;s a single central mountain, by computing the distance from the centre:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> dim = <span class="hljs-number">256</span>;
<span class="hljs-keyword">let</span> sugar = <span class="hljs-keyword">new</span> field2D(dim);
<span class="hljs-keyword">let</span> center = <span class="hljs-keyword">new</span> vec2(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);

sugar.set(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
    <span class="hljs-comment">// convert x, y in to 0..1 range:</span>
    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> vec2(x / dim, y / dim);
    <span class="hljs-comment">// get distance from center:</span>
    <span class="hljs-keyword">var</span> d = p.distance(center);
    <span class="hljs-comment">// make concentration high at center, lower with increasing distance:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> - d;
})
</code></pre>
<p>Or, for a more interesting and variegated landscape, we can start from uniform noise, and then smoothen it out:</p>
<pre><code class="lang-javascript">//<span class="hljs-built_in"> fill </span>with uniform noise
sugar.set(function(x, y) {<span class="hljs-built_in"> return </span>random(); });
// smoothen it out by<span class="hljs-built_in"> long-range </span>diffusion:
sugar.diffuse(sugar.clone(), sugar.width, 100);
// make it vary between 0<span class="hljs-built_in"> and </span>1:
sugar.normalize();
</code></pre>
<p>Or, we could design a CA to generate an interesting landscape, such as using a stochastic Monte Carlo process that prefers making neigbhour cells more similar, starting from a field of noise.</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// fill with uniform noise</span>
  sugar.set(function(x, y) { <span class="hljs-keyword">return</span> random()<span class="hljs-comment">; });</span>
  <span class="hljs-comment">// run a stochastic CA for a while:</span>
  <span class="hljs-keyword">for</span> (let i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;dim*dim*40; i++) {</span>
    <span class="hljs-comment">// pick a random cell:</span>
    let x0 = random(<span class="hljs-keyword">dim</span>)<span class="hljs-comment">;</span>
    let y0 = random(<span class="hljs-keyword">dim</span>)<span class="hljs-comment">;</span>
    let v0 = sugar.get(x0, y0)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a random neighbor:</span>
    let x1 = x0 + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    let y1 = y0 + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    let v1 = sugar.get(x1, y1)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// average them:</span>
    let v2 = (v0 + v1)*<span class="hljs-number">0.5</span><span class="hljs-comment">;</span>
    <span class="hljs-comment">// and update cell with this new value</span>
    sugar.set(v2, x0, y0)<span class="hljs-comment">;</span>
  }
  <span class="hljs-comment">// make it vary between 0 and 1:</span>
  sugar.normalize()<span class="hljs-comment">;</span>
</code></pre>
<h3 id="sensing-the-field">Sensing the field</h3>
<p>Sensing a field by &quot;smell&quot; is as simple as sampling the field&#39;s value at the agent&#39;s location. We can compute the nearest cell index to the agent, and then get the value:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// scale position (0..1) to field cell width</span>
<span class="hljs-comment">// and use Math.floor to round this to a whole number:</span>
let x = Math.floor(agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">0</span>] * sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
let y = Math.floor(agent.<span class="hljs-keyword">pos</span>[<span class="hljs-number">1</span>] * sugar.height)<span class="hljs-comment">;</span>
<span class="hljs-comment">// get field value at this cell:</span>
agent.sense = sugar.get(x, y)<span class="hljs-comment">;</span>
</code></pre>
<p>This is fine so long as we think of the environment as being really made up of discrete blocks in a grid. But in many cases, our grid-based field is only a <em>discrete approximation</em> of a continuous field. In that case, sensing single discrete cells breaks the approximation. What we really want is an approximate value taken between <em>all</em> the nearest cells. We can do this by <em>bilinear interpolation</em> between the four nearest cells, weighted according to which ones are closer or further from the specific agent position. This involves a lengthier bit of code, so the <code>field2D</code> object provides a convenient method for us:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// get an interpolated value from the field, </span>
<span class="hljs-comment">// using the nearest four cells to the agent's position:</span>
agent.sense = sugar.sample(agent.<span class="hljs-keyword">pos</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>We can test whether this is working by for example setting the hue of an agent before drawing:</p>
<pre><code class="lang-javascript">draw2D.<span class="hljs-keyword">color</span> = hsl(agent.sense)<span class="hljs-comment">;</span>
</code></pre>
<h3 id="responding-to-the-field">Responding to the field</h3>
<p>Once we have a sense, how should we respond? Here we need to equip our agent with some capabilities of taking <strong>action</strong>, as well as with a <strong>decision-making</strong> capability, sometimes known as <strong>action selection</strong>, that uses the input of sense to map to the output of action, in order to achieve a desired result. (The random walker&#39;s action was to change velocity, while decision-making was a simple mapping of a random number.)</p>
<p>When we look at microbiology we can find some remarkably simple action &amp; decision-making mechanisms to achieve effective goal satisfaction. Let&#39;s look at chemotaxis again. For example, the E. Coli bacterium&#39;s <em>goal</em> is to find the highest sugar concentration. But it has no eyes or ears to sense at a distance, it can only sense the local sugar concentration at its current location. It has no sense of direction, nor any internal &quot;map&quot;. Its range of actions are limited to twisting its flagella, resulting in just two modes of <em>locomotion</em>: </p>
<ul>
<li>Move forward more or less straight</li>
<li>Tumble about fairly randomly</li>
</ul>
<iframe width="720" height="540" src="https://www.youtube.com/embed/ZV5CfOkV6ek?rel=0" frameborder="0" allowfullscreen></iframe>

<p>We can certainly model these two modes of locomotion in an agent, by varing the factors of our random walker:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// tumbling behaviour:</span>
agent.vel.<span class="hljs-built_in">rotate</span>((<span class="hljs-built_in">random</span>()<span class="hljs-number">-0.5</span>)*<span class="hljs-number">2.0</span>).len(<span class="hljs-number">0.0005</span>);

<span class="hljs-comment">// swimming behaviour:</span>
agent.vel.<span class="hljs-built_in">rotate</span>((<span class="hljs-built_in">random</span>()<span class="hljs-number">-0.5</span>)*<span class="hljs-number">0.1</span>).len(<span class="hljs-number">0.005</span>);
</code></pre>
<p>But how does this solve the problem? </p>
<hr>
<p>E. Coli uses a very simple chemical <strong>memory</strong> to detect whether the concentration at the current moment is better, worse, or not much different to how it was a few moments ago. That is, it detects the differential experienced, or gradient traversed. Knowing whether things are getting better or worse is used to select between the swimming or tumbling patterns. With just a few tuning parameters, the method can lead to a very rapid success. </p>
<p>So all we need is to compare the sugar concentration with the agent&#39;s memory (a stored member variable) of the concentration on the last time step, and choose the behaviour accordingly (and of course, store our sensed value in memory for the next update).</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// sense field here</span>
<span class="hljs-built_in">agent</span>.sense = sugar.sample(<span class="hljs-built_in">agent</span>.pos);
<span class="hljs-comment">// is life getting worse?</span>
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">agent</span>.sense &lt; <span class="hljs-built_in">agent</span>.memory) {
    <span class="hljs-comment">// tumbling behaviour:</span>
    <span class="hljs-built_in">agent</span>.vel.rotate((<span class="hljs-built_in">random</span>()-<span class="hljs-number">0.5</span>)*tumbleturn).len(<span class="hljs-built_in">agent</span>.<span class="hljs-built_in">size</span> * tumblespeed);
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// swimming behaviour:</span>
    <span class="hljs-built_in">agent</span>.vel.rotate((<span class="hljs-built_in">random</span>()-<span class="hljs-number">0.5</span>)*swimturn).len(<span class="hljs-built_in">agent</span>.<span class="hljs-built_in">size</span> *  swimspeed);
}
<span class="hljs-comment">// remember this:</span>
<span class="hljs-built_in">agent</span>.memory = <span class="hljs-built_in">agent</span>.sense;
</code></pre>
<p>Note that this method works when the variations of sugar concentration in the environment are fairly smooth, which is generally true for an environment in which concentrations diffuse. Try again with noisy or homogenous environments, and see how well the agent fares.</p>
<h3 id="continuations">Continuations</h3>
<p>So far, our sugar field is static. It would be nice to see what a continuously dynamic field offers. </p>
<p>For example, we could let the mouse add more sugar to the space, and watch it gradually diffuse away. Adding sugar in response to the mouse is fairly easy, by making use of the <code>deposit</code> method of field2D. This method accumulates into the field at a point coordinate, adding to its existing values. Note that the coordinate is in the normalized 0..1 range, and that it will spread the value over the nearest four cells:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouse</span><span class="hljs-params">(e, pt)</span> </span>{
    <span class="hljs-comment">// add one unit of sugar at the location of the mouse:</span>
    sugar.deposit(<span class="hljs-number">1</span>, pt);
}
</code></pre>
<p>We could also remove the need of human input by creating another kind of agent, as the &quot;source&quot;, randomly wandering the space and depositing sugar as it goes. </p>
<p>So far this isn&#39;t completely effective to attract agents, as there can be large spatial discontinuities. If agents happen to be on part of a drawn path, they might follow it, but otherwise they are unlikely to find it. </p>
<p>To create a smoother gradient, we must diffuse the field continuously. To add continuous dynamics, we need to add field processing to our <code>update()</code> routine. And since the <code>diffuse()</code> method requires a distinct source field, we&#39;ll need to double buffer like before:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> sugar_past = sugar.<span class="hljs-keyword">clone</span>();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// swap fields:</span>
    <span class="hljs-keyword">let</span> tmp = sugar_past;
    sugar_past = sugar;
    sugar = tmp;
    <span class="hljs-comment">// diffuse it</span>
    sugar.diffuse(sugar_past, <span class="hljs-number">0.1</span>);

    <span class="hljs-comment">//... update agents as before</span>
}
</code></pre>
<p>Now the agents are able to find the areas of sugar more easily -- and might even show something like trail-following.</p>
<p>We might also notice that even when the sugar is quite dissipated, the agents can still find the strongest concentrations. If we don&#39;t find this realistic, one thing we might consider adding is a low level of background randomness. The rationale is that even if sensing is perfectly accurate, small fluctuations in the world (such as due to the Brownian motion of water and sugar molecules) make it impossible to discern very small differences. The randomness added must be signed noise, balanced around zero such that overall the total intensity is statistically preserved. Note that the amplitude of this noise will have to be extremely high if it is applied <em>before</em> the diffusion, or very low if applied <em>after</em> diffusion. The effective results are also quite different.</p>
<pre><code class="lang-javascript">    <span class="hljs-comment">// applied after sugar.diffuse:</span>
    <span class="hljs-comment">// use field2D.map() to modify a cell value</span>
    <span class="hljs-comment">// adding a small random deviation</span>
    <span class="hljs-comment">// whose average is zero</span>
    sugar.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{ 
        <span class="hljs-keyword">return</span> v + <span class="hljs-number">0.01</span>*(random() - <span class="hljs-number">0.5</span>);
    });
</code></pre>
<p>Still, the sugar just seems to accumulate over time, and the more we draw, the more the screen tends to grey. This is because our diffuse() method spreads intensity out, but does not change the total quantity. We need some other process to reduce this total quantity to make a balance. One way to do that is to add a very weak overall decay to the field -- as if some particles of sugar occasionally evaporate:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// in update():</span>
    sugar.mul<span class="hljs-comment">(0.99)</span>;
</code></pre>
<p>Of course, our agents aren&#39;t just looking for sugar to show it to us -- they want to eat it! We can also add the effect of this on the environment by <em>removing</em> intensity from the field by each agent. We can do this by calling the <code>field2D.deposit()</code> method with a negative argument (i.e. a debit!):</p>
<pre><code class="lang-javascript">    <span class="hljs-comment">// get the sugar level at this location:</span>
    var sense = Math.max(sugar.sample(a.<span class="hljs-keyword">pos</span>), <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// update the field to show that we removed sugar here:</span>
    sugar.deposit(-sense, agent.<span class="hljs-keyword">pos</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Note however this might lead to some locations getting negative concentrations -- a physical impossibility? We could fix this by clamping the field values as another step:</p>
<pre><code class="lang-javascript">    sugar.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(v)</span> </span>{ 
        <span class="hljs-keyword">return</span> clamp(v, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
    });
</code></pre>
<blockquote>
<p><strong>Aside</strong>: A very different alternative to diffusion, scaling, adding noise, clamping etc. is to use something closer to an asynchronous CA, in continuous process, rather as we did before for field initialization. This makes a more challenging, but more interesting, dynamic landscape for the agents to navigate:</p>
</blockquote>
<pre><code class="lang-javascript">  <span class="hljs-comment">// some swaps:</span>
  <span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;10000; i++) {</span>
    <span class="hljs-comment">// pick a point at random</span>
    var x = random(sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
    var y = random(sugar.height)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a neighbour</span>
    var x1 = x + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    var y1 = y + random(<span class="hljs-number">3</span>)<span class="hljs-number">-1</span><span class="hljs-comment">;</span>
    <span class="hljs-comment">// get the values</span>
    var a = sugar.get(x, y)<span class="hljs-comment">;</span>
    var b = sugar.get(x1, y1)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// pick a random interpolation factor</span>
    var t = <span class="hljs-number">0.5</span>*random()<span class="hljs-comment">;</span>
    <span class="hljs-comment">// blend a and b into each other accordingly</span>
    var a1 = a + t*(b-a)<span class="hljs-comment">;</span>
    var b1 = b + t*(a-b)<span class="hljs-comment">;</span>
    <span class="hljs-comment">// write these values back to the field</span>
    sugar.set(a1, x, y)<span class="hljs-comment">;</span>
    sugar.set(b1, x1, y1)<span class="hljs-comment">;</span>
  }
  <span class="hljs-comment">// some removals:</span>
  <span class="hljs-keyword">for</span> (var i=<span class="hljs-number">0</span><span class="hljs-comment">; i&lt;100; i++) {</span>
    var x = random(sugar.<span class="hljs-keyword">width</span>)<span class="hljs-comment">;</span>
    var y = random(sugar.height)<span class="hljs-comment">;</span>
    sugar.set(<span class="hljs-number">0</span>, x, y)<span class="hljs-comment">;</span>
  }
</code></pre>
<blockquote>
<p>Obviously there&#39;s a hint here of how it might be interesting to pair our agents with some other CAs for field processes... perhaps the Forest Fire model, for example.</p>
</blockquote>
<h2 id="the-model-so-far-">The model so far:</h2>
<p>An agent-based system can comprise:</p>
<ul>
<li>a <strong>population</strong> of agents, each with:<ul>
<li><strong>position</strong> </li>
<li><strong>mobility</strong>, e.g. as velocity</li>
<li>other <strong>properties</strong> such as size, colour, etc.</li>
<li><strong>decision-making</strong> that may relate the above with:<ul>
<li><strong>input senses</strong> such as field smell</li>
<li><strong>output actions</strong> such as changes to velocity</li>
<li><strong>memory</strong></li>
</ul>
</li>
</ul>
</li>
<li>an <strong>environment</strong>, with:<ul>
<li><strong>boundary conditions</strong></li>
<li><strong>initial conditions</strong></li>
<li><strong>continuous processes</strong> including addition, removal, diffusion, limiting, stochastics, etc.</li>
</ul>
</li>
</ul>
<!-- 

All of 'what is an agent' up to Reynolds flocking.

[See the random walker example here](http://codepen.io/grrrwaaa/pen/mVBBPQ?editors=001). Rather than simple deviations to the current heading, this follows Reynold's method to generate headings based on deviations of an ideal point just ahead of the agent, which is more parametrically defined.

[And here are many walkers](http://codepen.io/grrrwaaa/pen/YwEbRO?editors=001) -- to help demonstrate how to support populations, and how quickly random walkers can cover a terrain. This is on reason why random walks feature in many foraging behaviours in nature.


> A variety of other *taxes* worth exploring can be found on the [wikipedia page](http://en.wikipedia.org/wiki/Taxis#Aerotaxis). Note how chemotaxis (and other taxes) can be divided into positive (attractive) and negative (repulsive) characters, just like forces (directly seen in steering forces). This is closely related to the concepts of positive and negative feedback and the explorations of cybernetics.

Continue at stigmergy?

Or consider the other kind of enviornment: each other?

Or continue at Birth & Death?



![Fish school](http://underthecblog.files.wordpress.com/2014/02/fishschool.gif)

Some of the most beautiful, fascinating or strange phenomena of nature can be understood as emerging from the behaviors of interacting agents. Widely acknowledged examples include the murmuration of birds (or swarming insects, schools of fish), and the societal 'superorganisms' of ant colonies. We have come to understand that despite the obvious organization that we see at the macro-scale, there is no hierarchical center of coordination, but rather the whole emerges from simple interactions at local levels. These have been suggested as examples of emergence, or of self-organization. Which is to say, the whole is greater than a naive sum of its parts. 
-->

	</div>
	<footer>&copy; 2018 Graham Wakefield</footer>
  </body>
</html>