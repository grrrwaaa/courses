<!DOCTYPE html>
<html>
  <head>
	<title>Cellular Automata</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="DATT4950">DATT4950</a></li>
<li><a href="gallery.html" alt="Gallery">Gallery</a></li>
<li><a href="themes.html" alt="Themes">Themes</a></li>
<li><a href="cellular.html" alt="Cellular Automata">Cellular Automata</a></li>
<li><a href="agent.html" alt="Agents">Agents</a></li>
<li><a href="evo.html" alt="Evolutionary Systems">Evolutionary Systems</a></li>
<li><a href="labs.html" alt="Labs">Labs</a></li>
<li><a href="js.html" alt="JavaScript">JavaScript</a></li>
	</ul>
	</nav>	
	<div id="main">
	<h1 id="cellular-automata-and-related-lattice-models-">Cellular automata (and related lattice models)</h1>
<p>The mathematical notion of <em>automaton</em> indicates a discrete-time system with finite set of possible states, a finite number of inputs, a finite number of outputs, and a transition rule which gives the state at the next step in terms of the state and inputs at the previous step. </p>
<p>A <em>Cellular Automaton</em> applies this notion in parallel to a cellular space, in which each cell of the space is a stateful automaton. The essential components that define a cellular system are:</p>
<ul>
<li><p><strong>Cellular space:</strong> A collection of cells arranged into a discrete lattice, such as a 2D grid. The space is usually 1D, 2D or 3D, but rarely greater. </p>
</li>
<li><p><strong>Cell states:</strong> The information representing the current condition of a cell. In binary CAs this is simply either 0 or 1.</p>
</li>
<li><p><strong>Initial conditions:</strong> What state the cells are in at the start of the simulation.</p>
</li>
<li><p><strong>Neighborhood:</strong> The set of adjacent/nearby cells that can directly influence the next state of a cell. The most common 2D neighborhoods are: <img src="http://www.economicsnetwork.ac.uk/cheer/ch17/hand1.gif" alt="neighborhoods"></p>
</li>
<li><p><strong>State transition function:</strong> The rule that a cell follows to update its state, which depends on the current state and the state of the neighborhood. It gives the cell state[t+1] as a function of the states[t] of itself and neighbours. </p>
</li>
<li><p><strong>Time axis:</strong> The cells are generally updated in a discrete fashion, which may be synchronous (all cells update simultaneously) or asynchronous (cells update sequentially).</p>
</li>
<li><p><strong>Boundary conditions:</strong> What happens to cells at the edges of the space. A periodic boundary &#39;wraps around&#39; to the opposite edge; a static boundary always has the same state, a reflective boundary mirrors the neighbor state.</p>
</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/Nobili_Pesavento_2reps.png" alt="von Neuman CA"></p>
<p>The CA model was propsed by Stanislaw Ulam and used by <a href="https://en.wikipedia.org/wiki/Von_Neumann_universal_constructor">von Neumann</a> -- in the 1940&#39;s -- to demonstrate machines that can reproduce themselves. Decades later Christopher Langton proposed a more concise <a href="http://www.youtube.com/watch?v=2iDc4C6vbcc">self-reproducing CA</a>, which has since been further improved upon using artificial evolutionary techniques:</p>
<iframe width="480" height="360" src="https://www.youtube.com/embed/vbpoTZlNTiw?rel=0" frameborder="0" allowfullscreen></iframe>

<p>CAs are not just for exploring this question. Christopher Adami describes CAs as the first &quot;artificial chemistries&quot;, since they operate as a medium to research the continuum between the (such as molecules in crystal and metalline structures) and the living (such as cells of a multi-cellular organism). Thus they can be used to model all kinds of information processing and development in biological systems, as well as questions of life&#39;s origins. (However the computational cellular systems we will visit are far, far simpler than biological cells.)</p>
<p>Stephen Wolfram, author of Mathematica, performed extensive research on CAs and uncovered general classes of behaviour comparable to dynamical systems. A commonly referenced example is his &#39;rule 30&#39;, which is a 1D CA displayed below as a stacked trace (history goes down) -- whose pattern is reminiscent of some naturally occurring shell patterns:</p>
<p><img src="img/ca_shells.jpg" alt="Evolution of a 1D CA: rule 30"></p>
<iframe width="480" height="360" src="https://www.youtube.com/embed/jDguxopxyJk?rel=0" frameborder="0" allowfullscreen></iframe>

<p>Here are some of the well-known 1D rules:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="NeLQvY" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="1D Rules: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/NeLQvY/">1D Rules: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>Wolfram divided CA into four classes, according to their long-term behavior:</p>
<ul>
<li><strong>Class 1</strong> - stable. Evolves to homogeneous state.</li>
<li><strong>Class 2</strong> - cyclic. Evolves to simple separated periodic structures. Local changes to the initial pattern tend to remain local</li>
<li><strong>Class 3</strong> - chaotic. Any stable structures that appear are quickly destroyed by the surrounding noise. Local changes to the initial pattern tend to spread indefinitely</li>
<li><strong>Class 4</strong> - complex. Local changes to the initial pattern may spread indefinitely. Wolfram has conjectured that many, if not all class 4 cellular automata are capable of universal computation.</li>
</ul>
<hr>
<p><a href="https://www.youtube.com/watch?v=wNypW-aSCmE">Over here a 3D cellular automaton is taking over Minecraft</a>, and <a href="http://www.youtube.com/watch?v=PBXO_6Jn1fs">here is a self-replicating computer in 3D</a>.</p>
<p><a href="http://www.interciencia.es/PDF/WikipediaBooks/CellAutomata.pdf">The wikibooks on CA</a>.</p>
<hr>
<h3 id="conway-s-game-of-life">Conway&#39;s Game of Life</h3>
<p>The most famous CA is probably the <strong>Game of Life</strong>. It is a 2D, class 4 automata, which uses the Moore neighbourhood (8 neighbours), and synchronous update. The transition rule can be stated as follows:</p>
<ul>
<li>If the current state is 1 (&quot;alive&quot;):<ul>
<li>If the neighbor total is less than 2: New state is 0 (&quot;death by loneliness&quot;)</li>
<li>Else if the neighbor total is greater than 3: New state is 0 (&quot;death by overcrowding&quot;)</li>
<li>Else: State remains the same (&quot;alive&quot;)</li>
</ul>
</li>
<li>If the current state is 0 (&quot;dead&quot;):<ul>
<li>If the neigbor total is exactly 3: New state is 1 (&quot;reproduction&quot;)</li>
<li>Else: State remains the same (&quot;dead&quot;)</li>
</ul>
</li>
</ul>
<blockquote>
<p>It is thus an example of a <em>outer totalistic</em> CA: The spatial directions of cells do not matter, only the total value of all neighbors is used, along with the current value of the cell itself. Note also that these rules mean that the Game of Life is not reversible: from a given state it is not possible to determine the previous state.</p>
</blockquote>
<p>The Game of Life produces easily recognizable higher-level formations including stable objects, oscillatory objects, mobile objects and objects that produce or consume others, for example, which have been called &#39;ponds&#39;, &#39;gliders&#39;, &#39;eaters&#39;, &#39;glider guns&#39; and so on. </p>
<p>This CA is so popular that people have written <a href="http://www.youtube.com/watch?v=My8AsV7bA94">Turing machines</a> and, recursively, the <a href="http://www.youtube.com/watch?v=xP5-iIeKXE8">Game of Life</a> in it. </p>
<h3 id="implementation">Implementation</h3>
<p>If the cells are densely packed into a regular lattice structure, such as a 2D grid, they can efficiently be represented as <em>array</em> memory blocks. The state of a cell can be represented by a number, so an array of integers works well. A way to index this array memory to read or write a cell coordinate will be useful.</p>
<p>In theory the transition rule can be represented as a <em>look-up table</em>, however above a certain number of states and neighbors the size of this table would become astronomical (k states raised to the power of k neighbor states raised to the power of n neighbors; for a 3-state, 3-neighbor system this requires 7 billon rules!), so a procedural implementation is preferable. CAs may use bit-wise operators to implement the transition rules in a hardware-optimized way, but we will use regular <code>if</code> statements for clarity. </p>
<p>One complication is that the states of the whole lattice must update synchronously. That means: when one cell changes, all cells should change. This is not easy to achieve in most computing systems today, which mostly follow instructions one at a time (with only limited parallelism). A naive implementation will thus update cells one at a time, and the neighborhood of a particular cell will contain both &#39;past&#39; and &#39;future&#39; states. One way to work around this is to maintain two copies of the lattice; one for the &#39;past&#39; states, and one for the &#39;future&#39; states. The transition rule always reads from the &#39;past&#39; lattice, and always writes to the &#39;future&#39; lattice. After all cells are updated, either the &#39;future&#39; is copied to the &#39;past&#39;, or the &#39;future&#39; and &#39;past&#39; lattices are swapped, since the future of yesterday is the past of tomorrow. </p>
<blockquote>
<p>This technique is called <em>double-buffering</em>, and is widely used in software systems where a parallel process interacts with a serial machine. It is used to render graphics to the screen, for example.</p>
</blockquote>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="JwprVG" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="2019 DATT4950 Jan 3" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/JwprVG/">2019 DATT4950 Jan 3</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<hr>
<h2 id="variations">Variations</h2>
<p>There are many ways we can modulate this into more complex CA. For example, by allowing more than two states. For example, here is &quot;Brian&#39;s Brain&quot;:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="JwaQqV" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Brian's Brain: 2019 DATT4950" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/JwaQqV/">Brian&#39;s Brain: 2019 DATT4950</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>More variations are possible by modulating the basic definition of a CA, some of which have been explored more than others. </p>
<h2 id="probabilistic-stochastic-ca">Probabilistic/Stochastic CA</h2>
<p>In this case the transition rule is not deterministic, but includes some (pseudo-)randomized factors. This can help avoid the CA falling into a stable or cyclic pattern -- at the risk of descending into uninteresting noise.</p>
<ul>
<li>A probability can be assigned to each successor state according to the prior states. For example, take a look at the Forest Fire CA below, and try changing the probabilities to see how it behaves:</li>
</ul>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="OroeKW" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Forest Fire: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/OroeKW/">Forest Fire: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<ul>
<li>A <em>backround noise</em> can be added, such that from time to time a randomly chosen cell changes state. Try adding background noise to the Game of Life to avoid it reaching a stable or cyclic attractor. But too high a probability and it descends into noise. Try adding a <em>temperature</em> control to control the statistical frequency of such changes. Could something <em>intrinsic</em> to the system determine temperature? Could this vary over space?</li>
<li>Probabilistic/statistical choices can be combined with other variations below, such as spatially non-homogenous probabilities, statistical rules and neighbourhoods, etc.</li>
</ul>
<h2 id="non-homogenous-ca">Non-homogenous CA</h2>
<p>The rule is not the same for all cells / for all time steps. Spatial inhomogeneity can be interesting to simulate different geographies (such as boundaries). The simplest option is to prime the system with inhomogeneous initial conditions, but these differences can quickly dissipate, whereas varying other components of a CA spatially can have more profound results (though, as with randomness, care may need to be taken that these differences do not overly dominate the process).</p>
<ul>
<li>Creating unusual neighbourhoods (or simply, non-totalistic ones) can introduce interesting spatial biases to behaviour.</li>
<li>Special <em>boundary</em> cells in the field may follow different rules from others.</li>
<li>Some rules may depend on the cell position; perhaps the same CA has different regions using different rules. These can be implemented by changing the function used in the transition rule, or by extending the state set to accommodate the differences. Changing the function is usually easier to implement and understand.</li>
</ul>
<p>Temporal non-homogeneity can be used to perform a sequence of different filters, or otherwise help to build long- as well as short-term arcs of behaviour.</p>
<ul>
<li>The neighborhood selection rules could change over time (also see particle CA below).</li>
<li>The rules used could alternate between different rule definitions, over a period of N frames. Or certain parameters to rules could cycle over certain periods. Scott Draves&#39; <a href="http://scottdraves.com/bomb.html">Bomb</a> modulated parameters continuously, with different rule sets picking up the last as their new initial conditions.</li>
<li>Variations of space/rule/neighborhood could depend on global conditions, such as the overall density of black and white cells, or due to user interactions.</li>
<li>Other combinations of the above (and below)</li>
</ul>
<p>One has to be careful though: it could be that introducing these variations is not really different to a slightly more complex, but homogenous, CA.</p>
<h2 id="asynchronous-ca">Asynchronous CA</h2>
<p>Rather than updating all cells at once, some other policy of visiting cells to update is applied.</p>
<ul>
<li><p>A fixed update policy, such as linear scan or pre-determined path, is orderly, but may introduce artifacts (related to the <em>double-buffering</em> pattern). A randomized, but still fixed, order can still lead to artifacts.</p>
</li>
<li><p>A multi-rate CA (self-clocked) updates each cell according to a clock period that varies from cell to cell. This implies that each cell must have more than one value (one to store the state, one to store the period, one to store the phase) -- or equivalently, that there is more than one cellular grid. The clock period or phase could be affected by that of neighbours&#39;. This may lead to <em>entrainment</em> effects. </p>
</li>
<li>Mobile CA (see below)</li>
<li>Probabilistic asynchrony (see below)</li>
</ul>
<h3 id="mobile-ca">Mobile CA</h3>
<p>A <em>mobile CA</em> has a notion of active cells. The transition rule is only applied to active cells, and must also specify a related cell (such as one of the neighbors) of the current active cell as the next active cell. (This could also be partly probabilistic.) </p>
<p>There could be more than one &#39;active cell&#39; -- there could even be a list of currently active cells. Non-active cells are then described as &quot;quiescent&quot;. But what happens if two active cells occupy the same site?</p>
<h4 id="langton-s-ant">Langton&#39;s Ant</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Langton%27s_ant">Langton&#39;s Ant</a> is a mobile CA in a 2D, two-state space, with very simple rules:<ul>
<li>At a white square, turn 90° right, flip the color of the square, move forward one unit</li>
<li>At a black square, turn 90° left, flip the color of the square, move forward one unit</li>
</ul>
</li>
</ul>
<p>See our JavaScript version:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="RWrdoq" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Langton's Ant: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/RWrdoq/">Langton&#39;s Ant: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>A variation with multiple ants:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="LMJwVP" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Multiple Langton Ants: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/LMJwVP/">Multiple Langton Ants: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<iframe width="640" height="360" src="https://www.youtube.com/embed/hy3LG6isnQA?rel=0" frameborder="0" allowfullscreen></iframe>

<p>The <a href="http://www.youtube.com/watch?v=w6XQQhCgq5c">original video by Christopher Langton</a>, including examples of multiple ants (and music by the Vasulkas):</p>
<iframe width="480" height="360" src="https://www.youtube.com/embed/w6XQQhCgq5c?rel=0" frameborder="0" allowfullscreen></iframe>

<blockquote>
<p>Note that Langton&#39;s Ant, and other related Turmites, are closely related to the turtle graphics often used for L-systems, which we will return to later in the course.</p>
</blockquote>
<h3 id="termites">Termites</h3>
<p>Mitchel Resnick&#39;s termite model is a random walker in a space that can contain woodchips, in which each termite can carry one woodchip at a time. The program for a termite looks something like this:</p>
<ul>
<li>Look at the space just in front of me</li>
<li>If it is empty, move forward and randomly change direction (random walk)</li>
<li>Else if it is occupied by a woodchip:<ul>
<li>If I am carrying a wood chip, drop mine where I am and turn around</li>
<li>Else move forward and pick up the woodchip</li>
</ul>
</li>
</ul>
<p>Over time, the termites begin to collect the woodchips into small piles, which gradually coalesce into a single large pile of chips.</p>
<h2 id="particle-ca-and-lattice-gas-automata">Particle CA and Lattice-Gas Automata</h2>
<p>If the transition rule (or, the set of transition rules as a whole) is careful to preserve a total cell values before and after, it can give the impression of a mass-conserving system, such as modeling the motion of particles and fluids. The elementary 1D traffic CA <a href="http://atlas.wolfram.com/01/01/184/">(rule 184)</a> is a simple particle CA. </p>
<h3 id="block-rule-ca">Block rule CA</h3>
<p>Since mass-preservation can be ensured by considering the neighbourhood before <em>and</em> after each transition, rules are often expressed in terms of a <em>block</em>. For a 2D CA, the simplest block is a 2x2 region (the <em>Margolus neighborhood</em>).</p>
<p><img src="img/mnhood.gif" alt="Margolus neigborhood"></p>
<p>A clever technique to simulate block-based rules is to shift the block grid on each successive frame, such that the even-aligned and then odd-aligned blocks interleave  (<a href="http://en.wikipedia.org/wiki/Block_cellular_automaton">see wikipedia</a>). Note that a block rule CA does not need to be double-buffered, since block updates do not overlap. </p>
<p>Examples of 2x2 block rule CA are listed <a href="http://psoup.math.wisc.edu/mcell/rullex_marg.html">here</a> -- many of these are implemented below:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="NGxJpP" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Block Rules: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/NGxJpP/">Block Rules: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><img src="img/zuse.jpg" alt="Zuse&#39;s vision of nature"></p>
<blockquote>
<p>In 1969, German computer pioneer (and painter) Konrad Zuse published his book <a href="ftp://ftp.idsia.ch/pub/juergen/zuserechnenderraum.pdf">Calculating Space</a>, proposing that the physical laws of the universe are discrete by nature, and that the entire universe is the output of a deterministic computation on a single cellular automaton. This became the foundation of the field of study called <em>digital physics</em>. Zuse&#39;s first model is a 3D particle CA.</p>
</blockquote>
<p>A CA-inspired digital physics hypothesis is currently being promoted by Stephen Wolfram, as described in his magnum opus <a href="http://www.wolframscience.com/nksonline/toc.html">A New Kind Of Science</a>.</p>
<h3 id="some-observations">Some observations</h3>
<ul>
<li><p>The block-rule CA especially hints at another interpretation of CA as a pattern-based <em>rewriting system</em> -- a point we will return to later in the course. And in fact, many CA can be understood as the application of pattern-based rewrites, in which a region of space that matches a given template pattern is replaced by a new region with the template&#39;s corresponding result (or action). </p>
</li>
<li><p>Clearly, mass-preserving CAs are guaranteed <em>not</em> to dissolve into homogenous final states -- which can alleviate any need for an external limiter to keep the balance -- but this does not mean they won&#39;t find a stable or cyclic end. On the other hand, CAs whose rules do not appear to preserve mass can still avoid dissolution into homogeneity.</p>
</li>
<li><p>Note that mass-preservation does not imply that the system is reversible. Reversibility is quite a different property, which states that each output neighbourhood can only be caused by a single predecessor neighbourhood. Some, but certainly not all, particle CAs are reversible.</p>
</li>
<li><p>Particle CA can also use probabilistic rules to simulate brownian motions and other non-deterministic media (but the rules would usually still need to be matter/energy preserving over long-term averages -- i.e. probabilities must balance to preserve mass). Particle CAs can also benefit from the inclusion of boundaries and other spatial non-homogeneities such as influx and outflow of particles at opposite edges to create more interesting gradients or otherwise keep the system away from equilibrium (a <em>dissipative system</em>).</p>
</li>
</ul>
<h3 id="probabilistic-asynchronous-ca">Probabilistic Asynchronous CA</h3>
<p>Chooses the next active cell according to a random selection.</p>
<p>The <em>Ising model</em> of ferromagnetism in statistical mechanics can be simulated in a <em>Monte Carlo</em> fashion: Each site (cell) has either positive or negative spin (we can encode that as 0 or 1 value). At each time step, consider a site at random, and evaluate the probability of changing state. If changing state moves the site closer to energetic equilibrium with its neighbors (determined according to the <a href="https://en.wikipedia.org/wiki/Hamiltonian_(quantum_mechanics">Hamiltonian</a>) of the site), then the change is made. Otherwise, the change is made only with a small probability that is dependent on the energetic difference and overall temperature. Thus at high temperatures, the system remains noisy, while at low temperatures it gradually self-organizes into all sites with equal spin.</p>
<p>[A simplified Ising model on codepen -- try changing the temperature:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="wREVKe" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Simple Ising: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/wREVKe/">Simple Ising: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>The <a href="https://en.wikipedia.org/wiki/Contact_process_(mathematics">contact process</a>) model has been used to simulate the spread of infection (and changes of opinion in voting): infected sites become healthy at a constant rate, while healthy sites become infected at a rate proportional to the number infected neighbours (see also the HodgePodge simulation below). This can be extented to multiple states for a multitype contact process.</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="bOxXEo" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="HodgePodge: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/bOxXEo/">HodgePodge: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="large-unbounded-complex-states">Large/unbounded/complex states</h3>
<p>The cellular <em>Potts model</em> (also known as the <em>Glazier-Graner</em> model) generalizes probabilistic asynchronous CA to allow more than two site states, and in some cases, an unbounded number of possible site states; however it still utilizes the notion of statistical movement toward neighbor equilibrium to drive change, though the definition of a local Hamiltonian. Variations have been used to model grain growth, foam, fluid flow, chemotaxis, biological cells, and even the developmental cycle of whole organisms. </p>
<blockquote>
<p>Note that in this subfield of research, the term <em>cell</em> is used not to refer to a site on the lattice, but to a whole group of connected sites that share the same state. So in modeling foam, a <em>cell</em> represents a single bubble, and is made of one or more <em>sites</em>. Most changes therefore happen at the boundaries between these cells.</p>
</blockquote>
<p>Stan Marée used this model to simulate the whole life cycle of <a href="http://www-binf.bio.uu.nl/stan/Thesis/">Dictyostelium discoideum</a>!</p>
<p>States need not be discrete integers -- in other systems the state could be represented by an n-tuple of values, or a recursive structure allowing unbounded complexity. </p>
<h2 id="continuous-automata">Continuous automata</h2>
<p>The CAs we have looked at so far are mostly discrete, and this is often evident in the results. But there are several ways in which we can try to approximate fully continuous automata -- and investigate to what extent similar properties or behaviours arise, and whether new properties can arise unique to continuous spaces. At the least, continuous automata are more able to show liquid and diffusive effects. But to proceed, we must consider each of the discrete aspects in turn:</p>
<p><strong>Continuous states:</strong> In this case, the states are not discrete (such as 0 or 1) but belong to a continuum (such as the linear range 0..1). We have seen some examples of this already (e.g. HodgePodge). The transition rule can no longer be a simple lookup table, but instead must map continuous ranges and/or functions. Comparators can be used to segment continuous space into ranges, and drive control flow, but the use of control flow implies that the output of the transition rule is still principally discontinuous. </p>
<p><strong>Continuous transition functions:</strong> One step further requires that the transition rule be expressible as a purely mathematical function, that is predominantly smooth. That is, all transition rules are combined into a single function, which handles both continuous input and produces continuous output. A <a href="https://en.wikipedia.org/wiki/Sigmoid_function">sigmoid function</a>, for example, is a continuous input &amp; output function that nevertheless approximates the states of discrete functions.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/600px-Logistic-curve.svg.png" alt="sigmoid"></p>
<p>Another option here is to introduce probabilistic functions. Finding a continuous system whose behaviours persist with the addition of some random noise is tantamount to finding an interesting system that is <em>robust to perturbations</em> -- a useful feature for anything that must interact with the real world!</p>
<p><strong>Continuous neighborhood:</strong> Instead of simply considering whole neighbor cells, we may want to apply some kind of weighted average over the surrounding region -- a sampling &quot;kernel&quot;.  Proper weighting of a kernel can eliminate much of the artifacts due to regular grid spacing. </p>
<p>The kernel could be simply expressed as an inner and outer radius, for example, or an ideal distance with sampling weighted according to a function of distance from this radius. </p>
<p>If radii are not expected to change, then kernel locations and weights can be pre-computed. Nevertheless, continuous neighborhood sampling can easily become processor-intensive. It may also be viable to explore a statistical sampling strategy, selecting each time only a random sub-set of the possible sampling locations to create a cheaper approximation of continuous sampling.</p>
<p>Another option is to apply an intermediate process of diffusion -- i.e. blur -- across the entire space between each application of the transition rule. However it is important that the diffusion kernel is mass-preserving -- that is, that repeated applications of the blur will not make the sum of all cell values greater or lesser.</p>
<p><strong>Continuous time:</strong> Instead of simply outputting a new state, change may be spread over time as a <em>differential</em>. That is, what is output from the transition function is an offset to accumulate to the current state. </p>
<p>This offset may also be distributed over a weighted neighbourhood, rather than a single state. </p>
<p>Another possible strategy to explore is delayed application (i.e., spreading the double-buffering over continuous time): maintaining copies of past and future cell states and interpolating between them. This can be used to smoothen the visual output of the CA, and also to support sampling the field at arbitrary points of time between frames.</p>
<h3 id="smoothlife">Smoothlife</h3>
<iframe width="640" height="360" src="https://www.youtube.com/embed/ISQChKRH4NI?list=PL69EDA11384365494" frameborder="0" allowfullscreen></iframe> 

<p><a href="http://www.youtube.com/playlist?list=PL69EDA11384365494">SmoothLife</a> uses a discrete grid, but all of states, kernel, and transition functions are adjusted for smooth, continuous values. A disc around a cell&#39;s center is integrated and normalized (i.e. averaged) for the cell&#39;s state, and a ring surrounding this is integrated &amp; normalized (averaged) for the neighbor state. Cell transition functions are expressed in terms of continuous sigmoid thresholds over the [0, 1] range, and re-expressed in terms of differential functions (velocities of change) to approximate continuous time. <a href="http://arxiv.org/pdf/1111.1567v2.pdf">Paper here</a>. By doing so, it removes the discrete bias and leads to fascinating results. <a href="http://www.youtube.com/watch?v=l7t8LtdBAV8">Another implementaton</a>. <a href="http://www.youtube.com/watch?v=zA857JdUn9o&amp;list=PL69EDA11384365494&amp;index=46">Taken to 3D</a>. In effect, by making all components continuous, it is essentially a simulation of differential equations. <a href="http://0fps.net/2012/11/19/conways-game-of-life-for-curved-surfaces-part-1/">Here is a great explanation of the SmoothLife implementation, with a jsfiddle demo</a></p>
<h3 id="lenia">Lenia</h3>
<p>Lenia continues in the spirit of SmoothLife, and has been extensively explored &amp; documented to identify over 400 different organisms, occuping distict environmental niches (different physical constants), with various locomotive patterns catalogued, etc.</p>
<iframe src="https://player.vimeo.com/video/277328815" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<ul>
<li><a href="https://arxiv.org/abs/1812.05433">Paper</a></li>
<li><a href="https://github.com/Chakazul/Lenia">Code</a></li>
<li><a href="https://virtualcreatures.github.io/">Winner in Virtual Creatures Contest, GECCO 2018, Kyoto</a></li>
<li><a href="http://artaward2018.alifelab.org/">Honorable Mention in ALife Art Award, ALIFE 2018, Tokyo.</a></li>
</ul>
<h3 id="reaction-diffusion">Reaction Diffusion</h3>
<p>The reaction-diffusion model was proposed by Alan Turing to describe embryo development and pattern-generation (<a href="http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf">Turing, A. The Chemical Basic for Morphogenesis.</a>); it is still used today in computer graphics (<a href="http://www.cc.gatech.edu/~turk/my_papers/reaction_diffusion.pdf">Greg Turk&#39;s famous paper</a>). RD systems and other differential equation systems can be approximated using continuous automata.</p>
<iframe width="480" height="360" src="https://www.youtube.com/embed/8dTmUr5qKvI?rel=0" frameborder="0" allowfullscreen></iframe>

<p>One approach to simulating RD using CA is the <em>Gray-Scott</em> model, as described in <a href="http://arxiv.org/pdf/patt-sol/9304003.pdf">Pearson, J. E. Complex Patterns in a Simple System</a>. A browser-based example is <a href="https://pmneila.github.io/jsexp/grayscott/">here</a>.</p>
<p>There is <a href="http://mrob.com/pub/comp/xmorphia/">a wonderful archive of this model at this webpage</a>, including many great video examples of the <a href="http://www.youtube.com/watch?v=F5oKgVZ6bTk">u-skate world</a>, and even <a href="http://www.youtube.com/watch?v=B03lcPEmSOQ">u-skate in 3D</a>. </p>
<p><img src="img/xmorphia-parameter-map.jpg" alt="The Gray-Scott parameter map"></p>
<p>Here is this model at a lower resolution using our starter kit:</p>
<p><p data-height="300" data-theme-id="18447" data-slug-hash="roZXmR" data-default-tab="js,result" data-user="grrrwaaa" data-pen-title="Reaction Diffusion: 2019" data-preview="true" class="codepen">See the Pen <a href="https://codepen.io/grrrwaaa/pen/roZXmR/">Reaction Diffusion: 2019</a> by Graham (<a href="https://codepen.io/grrrwaaa">@grrrwaaa</a>) on <a href="https://codepen.io">CodePen</a>.</p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>Some of these systems share resemblance with analog video feedback (<a href="http://www.youtube.com/watch?v=hDYEVv9t32U">example</a>, <a href="http://www.youtube.com/watch?v=Uw5onuS2_mw">example</a>), which has been exploited by earlier media artists (notably the Steiner and Woody Vasulka). </p>
<h2 id="spatial-transformation-systems">Spatial transformation systems</h2>
<p>Apart from smooth sampling, we can also introduce interesting behaviours by transforming the space itself as it is sampled. Different indexing rules (such as affine transformations of coordinate space) can be used to impart non-local symmetries and behavior. Different rules (or different neighborhood specifications) can be run in parallel on the same shared data. </p>
<p>Such transformations can effectively create non-standard neighbourhood rules.</p>
<p>Transformations can be global, or vary according to local field variations. For example, <a href="https://www.shadertoy.com/view/Xst3Dj">this beautiful viscous fingering shadertoy</a> uses continuous values and sampling along with a spatial rotation, where the rotation applied is a result of the field&#39;s <a href="https://en.wikipedia.org/wiki/Curl_(mathematics">curl</a>) (the infinitesimal rotation) at a particular point.</p>
<h3 id="ima-traveller">Ima Traveller</h3>
<p><img src="http://notnot.home.xs4all.nl/ima/overgadenL.jpg" alt="Ima Traveller"></p>
<p>Artists Driessens &amp; Verstappen created a recursive cellular system (exhibited in the artwork <em>IMA Traveller</em>) which appears to show an endless zoom; as the whole field appears to expand, each cell periodically subdivides into four daughter cells, following one of several rules to vary the color. Cells outside the viewpoint are thrown away. The effect is an infinitely expanding landscape or journey, which can be partially navigated by the gallery visitor. See the <a href="http://notnot.home.xs4all.nl/ima/IMAcat.html">info</a> link. 
<a href="http://notnot.home.xs4all.nl/ima/IMAtraveller.html">Driessens &amp; Verstappen: Ima Traveller</a></p>
<p>Ima traveller (1996) is interactive computer software for exploring an infinite universe. It enables you to make a journey into a space that is being created in real time. This space develops in the direction you are moving into, so there is no end to it. You travel forward in a smooth motion, you can drift in all directions, but you can never go back to where you came from. You are zooming in on a surface of infinite size, never reaching any boundaries.</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/Ueq7UyrzGK4?rel=0" frameborder="0" allowfullscreen></iframe>

<p>This work has inspired discussion by several critics, including <a href="http://www.tandfonline.com/doi/abs/10.1076/digc.14.1.43.8810">Mitchell Whitelaw</a> and <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.16.6640&amp;rep=rep1&amp;type=pdf&amp;utm_source=twitterfeed&amp;utm_medium=twitter">Jon McCormack and Alan Dorin</a>.</p>
<h3 id="multi-scale-systems">Multi-scale systems</h3>
<p>Several cellular systems can be coupled together at different scales. </p>
<ul>
<li>Perhaps each cell of a macro-CA is itself an entire micro-CA world. Or several CA can overlap with different spatial relationships. </li>
<li>Higher- and lower-level systems could progress at different rates (or statistical frequencies).</li>
</ul>
<iframe src="https://player.vimeo.com/video/137778082" width="720" height="405" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p><a href="http://www.jonathanmccabe.com/">Jonathan McCabe&#39;s cyclic multi-scale Turing patterns</a>, and a <a href="http://teemingvoid.blogspot.kr/2007/02/jonathan-mccabe-very-cellular-automata.html">commentary by Mitchell Whitelaw</a>. The implementation is described <a href="http://www.jonathanmccabe.com/Cyclic_Symmetric_Multi-Scale_Turing_Patterns.pdf">in this paper</a>.</p>
<p>It starts with a straightforward reaction-diffusion system:</p>
<ul>
<li>Diffusion is simulated by averaging the continuous cell values over small (activator) and large (inhibitor) radii; if the the smaller (activator) concentration is greater than the larger (inhibitor) concentration, increase the cell value by a small amount; otherwise decrease. </li>
<li>After running the rule over all cells, the entire field is <em>normalized</em> (to ensure the minimum cell value is zero and the maximum cell value is 1).</li>
</ul>
<p>Since this creates structure at a single spatial scale, it can be elaborated by super-imposing several models at different spatial scales (different small and large radii). Or, by changing the radii dynamically over time (as in <a href="http://www.cc.gatech.edu/~turk/my_papers/reaction_diffusion.pdf">Greg Turk&#39;s famous paper</a>). McCabe&#39;s system uses several pre-defined scales, but selects which scale to apply for a particular cell according to which one currently shows the least local variation. </p>
<p>Additionally, his system does not measure all cells within a radius; instead it selects cells at the radius distance and certain angular directions, creating cyclical symmetries in the result. For example, 3-fold symmetry may be used at a smaller scale, and 9-fold symmetry at a larger scale.</p>
<iframe width="640" height="360" src="https://www.youtube.com/embed/4Sz-iEdNFDc?rel=0" frameborder="0" allowfullscreen></iframe>

<h2 id="multi-way-ca-parallel-histories">Multi-way CA &amp; parallel histories</h2>
<p>In certain CA variants, more than one substitution could be valid to undertake. We have seen how some CA simply choose randomly between options, while Monte Carlo systems consider two or more options and take the one with the highest entropy. In a sense, for a brief moment, these systems follow two parallel histories, and then choose which one to discard. But there is no reason why we can&#39;t follow two (or more) histories for a little longer than a single step, nor to limit our decision-making to an energetic/entropic basis. We may return to this idea when exploring evolutionary systems, which present a similar parallelism. </p>
<blockquote>
<p>Wolfram also explored <a href="http://www.wolframscience.com/nksonline/page-204#previous">&#39;multi-way&#39;</a> CA executions, in which all possible histories for a given state are explored, considering their long-term evolutions, and in particular exploring which rules lead to exponentially more universes, which tend to stabilize, and which ultimately lead to the same results.</p>
</blockquote>

	</div>
	<footer>&copy; 2018 Graham Wakefield</footer>
  </body>
</html>