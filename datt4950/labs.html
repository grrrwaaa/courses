<!DOCTYPE html>
<html>
  <head>
	<title>Labs</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="DATT4950">DATT4950</a></li>
<li><a href="gallery.html" alt="Gallery">Gallery</a></li>
<li><a href="themes.html" alt="Themes">Themes</a></li>
<li><a href="cellular.html" alt="Cellular Systems">Cellular Systems</a></li>
<li><a href="labs.html" alt="Labs">Labs</a></li>
<li><a href="js.html" alt="JavaScript">JavaScript</a></li>
	</ul>
	</nav>	
	<div id="main">
	<h1 id="labs">Labs</h1>
<p><a href="http://paleofuture.com/blog/2011/8/24/the-push-button-school-of-tomorrow-1958.html"><img src="img/collaborative_coding.jpg" alt="Labs of the paleofuture"></a></p>
<p>Most of the examples we will work though in the labs will use the JavaScript programming language, embedded in web browsers. To make this easier, I have prepared a starter-kit template, from which all our in-lab examples will be written, and which students can easily fork and extend via Codepen.io&#39;s online editor. (I am happy however to also demonstrate taking these ideas into different environments, such as Max/MSP, Cinder, GLSL, Unreal, etc., and we may spend more time doing this in the later parts of the course.)</p>
<hr>
<h2 id="scripting-with-codepen">Scripting with Codepen</h2>
<p>Before anything, make sure you have a recent version of Chrome or Firefox to work with.</p>
<p>Then, make sure you have signed up for a (free) account on <a href="https://codepen.io">Codepen</a>.</p>
<h3 id="starting-a-new-script">Starting a new script</h3>
<p>To start a new script, <a href="https://codepen.io/grrrwaaa/pen/YdYMwB?editors=001">open the following link and then press the &quot;Fork&quot; button to create a new copy</a></p>
<p>Alternatively, click the button below, then close the CSS and HTML tabs:</p>
<form action="http://codepen.io/pen/define" method="POST" target="_blank">
<input id="data-input" type="hidden" name="data" value="{&amp;quot;title&amp;quot;:&amp;quot;DATT4950&amp;quot;,&amp;quot;description&amp;quot;:&amp;quot;Artificial Life&amp;quot;,&amp;quot;css_external&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;js_external&amp;quot;:&amp;quot;https://worldmaking.github.io/code/al2019.js&amp;quot;,&amp;quot;html&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;css&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;js&amp;quot;:&amp;quot;// see https://grrrwaaa.github.io/courses/datt4950/labs.html for available methods\n\n// initialization code here\n\nfunction update() {\n  // simulation code here\n}\n\nfunction draw() {\n  // rendering code here\n}&amp;quot;,&amp;quot;html_pre_processor&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;css_pre_processor&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;css_starter&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;css_prefix&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;js_library&amp;quot;:&amp;quot;&amp;quot;}">
<input type="submit" value="Create a new Codepen editor">
</form> 

<h3 id="opening-the-javascript-console">Opening the javascript console</h3>
<p>Codepen includes a console, but I don&#39;t recommend it; the browser&#39;s built in developer consoles are far better. Instead, learn how to find the javascript console for your browser of choice:</p>
<ul>
<li>Chrome: View &gt; Developer &gt; JavaScript Console</li>
<li>Firefox: Tools &gt; Web Developer &gt; Web Console</li>
</ul>
<h3 id="offline-saving-from-codepen">Offline / saving from Codepen</h3>
<p>You can export from Codepen to static HTML files using the Export (export as zip) button, which can be useful for keeping copies of your work. </p>
<p>Alternatively you can build a fully offline local file by downloading our library from <a href="https://worldmaking.github.io/code/al2019.js">here</a>, saving it as &quot;al2019.js&quot; in a local folder, and putting your code into an <code>html</code> file in the same folder starting from this template:</p>
<pre><code><span class="hljs-meta">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"al2019.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">

<span class="hljs-comment">// Your code goes here</span>
<span class="hljs-comment">// see http://grrrwaaa.github.io/courses/datt4950/labs.html for available methods</span>

<span class="hljs-comment">// initialization code here</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// simulation code here</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// rendering code here</span>
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><!-- 
Here's an example:

<p data-height="480" data-theme-id="0" data-slug-hash="EVPGOB" data-preview ="true" data-default-tab="result" data-user="grrrwaaa" class='codepen'>See the Pen <a href='http://codepen.io/grrrwaaa/pen/EVPGOB/'>Game of Life</a> by Graham (<a href='http://codepen.io/grrrwaaa'>@grrrwaaa</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="http://assets.codepen.io/assets/embed/ei.js"></script>

If the example above doesn't work, it might be that you are among the [~10% of users](http://webglstats.com) whose browsers don't yet support WebGL. You can check support [here](http://www.doesmybrowsersupportwebgl.com), and compare browser support [here](http://caniuse.com/#feat=webgl). Note that IE users need to have version 11, or use Edge. Chrome has had good support for a long time. Safari has supported WebGL since version 8. Firefox has partial support. 
-->
<h2 id="overview">Overview</h2>
<p>Graphics rendering uses the HTML5 Canvas, which is supported on most computers with recent versions of Chrome, Firefox or Safari. For simplicity&#39;s sake examples will be confined to a 2D world, and coded through simplified abstractions. This world has coordinates ranging from (0,0) in the top-left corner to (1,1) in the bottom right corner -- i.e. it assumes the world to be square shaped and unit length. </p>
<h2 id="callbacks">Callbacks</h2>
<p>The kit provides an event-based callback system, in which you implement specially-named functions to handle specific events.</p>
<p>For simulation updates, implement a function called <code>update(dt)</code>. The <code>dt</code> argument gives the delta time between updates (in seconds). Simulation can be paused and un-paused using the <code>Space</code> key.</p>
<p>To define how the canvas renders, implement a function called <code>draw(ctx)</code>. All graphics code should go into this callback. The <code>ctx</code> argument is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D">Canvas 2d context</a> which you can use for general 2D drawing.  Rendering can toggle fullscreen mode using the <code>Escape</code> key.</p>
<p>For simulation restarts, implement a function called <code>reset()</code>. This will be fired whenever you press the <code>Enter</code> key.</p>
<h3 id="interaction">Interaction</h3>
<p>Additional callbacks exist to detect mouse/touch and keyboard interaction respectively. </p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mouse</span>(<span class="hljs-params">event, point, id</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event, point, id);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">key</span>(<span class="hljs-params">event, key</span>) </span>{
    <span class="hljs-built_in">console</span>.log(event, key);
}
</code></pre>
<p>The events details are:</p>
<ul>
<li>mouse:<ul>
<li>&quot;down&quot;: a button was pressed. </li>
<li>&quot;up&quot;: a button was pressed. </li>
<li>&quot;move&quot;: mouse was moved (or dragged).</li>
<li>the <code>point</code> argument is an array of two coordinates, in the range 0,0 to 1,1 </li>
<li>the <code>id</code> argument identifies which the button(s) pressed</li>
</ul>
</li>
<li>touch (for touch-screen devices):<ul>
<li>&quot;start&quot;: a touch started </li>
<li>&quot;end&quot; or &quot;cancel&quot;: a touch was released</li>
<li>&quot;move&quot;: a touch moved</li>
<li>the <code>point</code> argument is a vec2 in the range 0,0 to 1,1 </li>
<li>the <code>id</code> argument identifies touches in the case of multitouch</li>
</ul>
</li>
<li>key:<ul>
<li>&quot;down&quot;: a key was pressed.</li>
<li>&quot;up&quot;: a key was released.</li>
<li>the <code>key</code> argument can be a string representation of the character pressed, such as &quot;a&quot;, &quot;2&quot;, &quot;Z&quot;, &quot;&gt;&quot; etc., or special strings such as &quot;Shift&quot;, &quot;Control&quot;, &quot;Alt&quot;, &quot;Meta&quot;, &quot;Enter&quot;, &quot;Backspace&quot; etc.</li>
</ul>
</li>
</ul>
<!-- 
### Persistence

Sometimes you want state of a simulation to persist between edits, so the world doesn't always begin from scratch. We have two more callbacks to help with this. 

First, implement the ```save()``` method to store all of the information you want to preserve between edits. It should return an object that can be properly encoded as JSON. 

```javascript
function save() {
    // create your 'data' object here to save:
    return data;
}
```

To recover this data when the page is reloaded (e.g. after an edit), implement the ```save()``` method, whose argument will contain a new copy of the stored data:

```javascript
function load(data) {
    // do stuff with data
}
```

Important limits on this system:

- The object stored will be encoded as JSON, which means:
    - Object keys can only be strings (other types will be converted to string).
    - Values can only be objects, arrays, numbers, strings, booleans, or null (**no functions!**)
    - Objects will not keep their class. E.g. vec2 objects will become simple arrays.
    - Objects/arrays cannot have circular structures -- e.g. an object can't have a reference to its parent -- i.e. objects/arrays must be unambiguous trees.
    - If you have the same object twice in the tree -- it will become two different objects in ```load()```. 

That means, you need to design your persistent state in ```save()``` in a way that represents the important parts of your simulation, and design a method for creating a new simulation in ```load()``` based on this data.

- Data is stored in a persistent localStorage linked to the URL and the browser, which means:
    - Loading in a different browser, or using http instead of http for example, will not restore the same data.

-->
<h2 id="globals">Globals</h2>
<p>The library provides a few extra global functions that are frequently needed:</p>
<p><code>random()</code> can be used to generate random numbers. Without an argument it returns rational numbers between 0 and 1; with a numeric argument it returns integers in the given range (e.g. useful for picking within an array).</p>
<p><code>wrap()</code> applies a Euclidean modulo (remainder after division) in such a way that the result is always positive and without reflections.</p>
<p><code>shuffle(arr)</code> randomly re-orders the array &#39;arr&#39;. It modifies the array in-place, and also returns it.</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">random</span>();        <span class="hljs-comment"> // a floating-point number between 0 and 1</span>
<span class="hljs-built_in">random</span>(<span class="hljs-number">6</span>);       <span class="hljs-comment"> // an integer between 0 and 5</span>
<span class="hljs-keyword">wrap</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment"> // returns 3 (whereas -1 % 4 would return -1)</span>
shuffle([<span class="hljs-keyword">a</span>, b, c]);<span class="hljs-comment"> // returns [b, a, c] or [c, b, a] or [a, b, c] etc.</span>
</code></pre>
<p>The <code>write()</code> function will output text above the main canvas. It may be more useful than calling <code>console.log()</code> in certain situations. </p>
<p>There are also a couple of global variables, used to measure time:</p>
<pre><code class="lang-javascript">console.<span class="hljs-built_in">log</span>(now);    <span class="hljs-comment">// the time in seconds since the script started</span>
console.<span class="hljs-built_in">log</span>(dt);    <span class="hljs-comment">// the delta time in seconds between each update()</span>
</code></pre>
<h2 id="field2d">field2D</h2>
<p>The <code>field2D</code> type represents a dense grids of cells of floating point numbers (typically but not necessarily in the range of zero to one). You can create a field like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> field = <span class="hljs-keyword">new</span> field2D(<span class="hljs-number">10</span>);  <span class="hljs-comment">// creates a 10 x 10 grid of cells</span>
</code></pre>
<p>Typically we will render a field in the <code>draw()</code> callback by calling the field&#39;s draw method:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>{
    field.draw();
}
</code></pre>
<p>By default field cells will be zero, which looks black. You can get and set individual field cells this way:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = field.<span class="hljs-keyword">get</span>(x, y);
field.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">value</span>, x, y);
</code></pre>
<p>Note that if x or y is out of bounds for the field, it will wrap around from the other side. So you are always guaranteed it will return or set a value. </p>
<p>To set the value of all cells at once, omit the x and y:</p>
<pre><code class="lang-javascript">// <span class="hljs-keyword">set</span> all <span class="hljs-keyword">field</span> cells <span class="hljs-keyword">to</span> <span class="hljs-number">1</span> (white):
<span class="hljs-keyword">field</span>.<span class="hljs-keyword">set</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>A more powerful feature of <code>field2D.set()</code> is that it can take a function instead of a number. When x and y are omitted, this function is called to update each cell in the field. The function receives as arguments the x and y position of the cell, so for example, this code initializes the field with a horizontal gradient:</p>
<pre><code class="lang-javascript">field.<span class="hljs-keyword">set</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>{
    <span class="hljs-keyword">return</span> x / <span class="hljs-keyword">this</span>.width;
});
</code></pre>
<p>Note that <code>field.set</code> returns the field itself, so it can be chained.</p>
<p>More useful methods:</p>
<pre><code class="lang-javascript">field.<span class="hljs-keyword">clear</span>();         <span class="hljs-comment">// set all field cells to zero, faster than field.set(0)</span>
field.normalize();     <span class="hljs-comment">// re-scales the field into a 0..1 range</span>

field.clone();     <span class="hljs-comment">// create a duplicate copy of the field</span>
field.<span class="hljs-keyword">copy</span>(another); <span class="hljs-comment">// copy the values of `another` field (must have the same size)</span>

field.<span class="hljs-built_in">min</span>();    <span class="hljs-comment">// returns the lowest cell value in the array</span>
field.<span class="hljs-built_in">max</span>();    <span class="hljs-comment">// returns the highest cell value in the array</span>
field.<span class="hljs-built_in">sum</span>();    <span class="hljs-comment">// adds up all cell values and returns the total</span>

field.scale(<span class="hljs-keyword">n</span>); <span class="hljs-comment">// multiply all cells by n; AKA field.mul(n);</span>
field.add(<span class="hljs-keyword">n</span>); <span class="hljs-comment">// add `n` to all cells</span>
</code></pre>
<p>Normally fields render their cells with hard edges, but you can render the field more smoothly by setting:</p>
<pre><code class="lang-javascript">field.<span class="hljs-keyword">smooth</span> = <span class="hljs-literal">true</span>;
</code></pre>
<h3 id="normalized-sampling">Normalized sampling</h3>
<p>There are some methods for interpolated reading/writing/modifying fields. These methods use x and y indices in a normalized 0..1 floating-point range rather than 0..width or 0..height integer range:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// returns interpolated value at the normalized position x,y</span>
var value = field.sample<span class="hljs-comment">(x, y)</span>;        
<span class="hljs-comment">// or, using a vec2:</span>
var value = field.sample<span class="hljs-comment">(agent.position)</span>;    

<span class="hljs-comment">// adds v to a field at position x, y</span>
<span class="hljs-comment">// (interpolated addition to nearest four cells)</span>
field.deposit<span class="hljs-comment">(v, x, y)</span>;    
<span class="hljs-comment">// also accepts vec2</span>
<span class="hljs-comment">// a negative deposit is a debit (subtraction from field)</span>
field.deposit<span class="hljs-comment">(-v, agent.position)</span>;

<span class="hljs-comment">// set the field at position x,y to value v </span>
<span class="hljs-comment">// (the four nearest cells will be interpolated)</span>
field.update<span class="hljs-comment">(v, x, y)</span>;
</code></pre>
<p>The field2D type also includes a diffusion method, which can be used to smoothly distribute values over time. It requires a second (previous) copy of the field to diffuse from. This method more than just a general blur -- it very accurately preserves mass before and after. So, for example, taking the <code>.sum()</code> of the input and output fields results in almost exactly the same quantity. </p>
<pre><code class="lang-javascript">// field_previous <span class="hljs-keyword">is</span> another field2D <span class="hljs-keyword">of</span> equal dimensions
// diffusion_rate <span class="hljs-keyword">is</span> a value between <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span>; a rate <span class="hljs-keyword">of</span> <span class="hljs-number">0</span> means no diffusion.
// accuracy <span class="hljs-keyword">is</span> an optional <span class="hljs-built_in">integer</span> <span class="hljs-keyword">for</span> the number <span class="hljs-keyword">of</span> diffusion steps; the <span class="hljs-keyword">default</span> <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>.
field.diffuse(field_previous, diffusion_rate, accuracy);
</code></pre>
<p>There are also a couple of classic functional programming methods. The <code>map(function)</code> method applies a function to each cell of the field in turn. The function arguments will be the current value of the cell and the x and y position, and the return value should be the new value of the cell (or nil to indicate no change). </p>
<p>The <code>reduce(function, initial)</code> method is used to reduce a field to a single value, such as calculating the total of all cells. This value is defined by the <code>initial</code> argument, passed to the function for each cell, and updated by its return value. Easier to explain by example:</p>
<pre><code class="lang-javascript">// multiply <span class="hljs-built_in">all</span> cells by <span class="hljs-number">2</span>: 
field.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value, x, y)</span></span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> * <span class="hljs-number">2</span>; });

// find the <span class="hljs-built_in">sum</span> total of <span class="hljs-built_in">all</span> cell values:
var total = field.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(sum, value, x, y)</span></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span> + <span class="hljs-keyword">value</span>;
}, <span class="hljs-number">0</span>);
</code></pre>
<h3 id="multi-channel-fields">Multi-channel fields</h3>
<p>Field cells are in fact 4-channel vectors, mapping to red, green, blue and alpha channels when rendered; however the methods described above are designed to simulate single-channel (greyscale) semantics.</p>
<p>Whereas <code>field.get</code> returns a single number (the red-channel value), <code>field.cell</code> returns the entire 4-plane vector as an array, which you can modify in-place to set a particular color:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// turn a cell red:</span>
var cell = field.cell(x, y)<span class="hljs-comment">;</span>
cell[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
cell[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
cell[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
</code></pre>
<p>Alternatively, you can pass an array to <code>field.set</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// turn a cell red:</span>
field.<span class="hljs-keyword">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <span class="hljs-keyword">x</span>, y);
</code></pre>
<p>The normalized indexing and updating also supports multiple channels:</p>
<pre><code class="lang-javascript"><span class="hljs-comment">// to sample a specific channel (0, 1, 2 or 3):</span>
field.sample(<span class="hljs-built_in">agent</span>.<span class="hljs-built_in">position</span>, channel);    

<span class="hljs-comment">// to update a single channel):</span>
field.deposit(<span class="hljs-number">0.1</span>, <span class="hljs-built_in">agent</span>.<span class="hljs-built_in">position</span>, channel);
<span class="hljs-comment">// to update several channels:</span>
field.deposit([<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.1</span>], <span class="hljs-built_in">agent</span>.<span class="hljs-built_in">position</span>);
</code></pre>
<h3 id="images">Images</h3>
<p>You can also load PNG images into a field2D. </p>
<pre><code class="lang-javascript">field.loadImage(<span class="hljs-string">"https://upload.wikimedia.org/wikipedia/commons/1/17/ArtificialFictionBrain.png"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Note: images will be resized to fit the field, not vice versa. Transparent PNGs are supported (the opacity information is in channel 4 of the field).</p>
<p>Note: images can take a little time to load. If you want something to happen only after the image is loaded, add a callback:</p>
<pre><code class="lang-javascript">field.loadImage(<span class="hljs-string">"https://upload.wikimedia.org/wikipedia/commons/1/17/ArtificialFictionBrain.png"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    write(<span class="hljs-string">"image is loaded!"</span>);
});
</code></pre>
<!-- 
## vec2

The ```vec2``` type gives us a useful abstraction of two-component vectors. Here are some ways of creating a vec2:

```javascript
var v0 = new vec2(x, y);
var v1 = new vec2();     // x and y components default to zero

v0 = vec2.create(x, y); // equivalent to above
v1 = vec2.create();

var v2 = v0.clone();    // remember, v2 = v0 would not make a new copy

var v3 = vec2.random(); // a vector with unit length but random direction
var v4 = vec2.random(0.1); // as above, but length is 0.1

var v5 = vec2.fromPolar(len, angle_in_radians);
var v6 = vec2.fromPolar(angle_in_radians);    // length is 1
```

Getting some useful properties:

```javascript
var d = v0.len();        // get the magnitude of the vector
var a = v0.angle();     // get the direction of the vector (in radians)
var d = v0.distance(v1);    // distance between two vectors
var a = v0.anglebetween(v1);    // angle between two vectors
var b = v0.equals(v1);  // true if both components are equal
var n = v0.dot(v1);        // dot product of two vectors (related to similarity)
```

There are many methods available to call on a vec2. Some basic setters:

```javascript
v0.set(x, y);    // update a vector's values
v0.set(v1);        // update by copying from another vector

// changing the length (magnitude) of a vector:
v0.len(n);    // update a vector's length
v0.limit(n);    // shortens a vector to length n if it was longer
v0.normalize(); // set's a vector's length to 1

// changing the orientation of a vector:
v0.negate(); // reverses a vector
v0.angle(a); // set a vector's direction (in radians)
v0.rotate(a); // rotates a vector's direction (by radians)
```

Almost all methods have both an in-place version and a standalone version. The in-place version is a method called on a vec2 object, which it will probably modify as a result. The standalone version is a method called on ```vec2``` itself, and requires an argument for the result.

```javascript
// standalone:
// vout is modified; v0 and v1 are not changed
vout = new vec2();
vec2.add(vout, v0, v1);    

// in-place:
// v0 is modified; like the scalar equivalent s0 += s1
v0.add(v1); 

// Since in-place methods return themselves, they can be chained:
v0.add(v1).sub(v1).mul(v1).div(v1); // etc.
```

Note that most method arguments will accept a number (i.e. a scalar), or an array, in place of a vector: So you can say ```v0.pow(2)``` rather than ```v0.pow(new vec2(2, 2))```. 

```javascript
// These are all equivalent:
v0.pow(new vec2(2, 2));
v0.pow([2, 2]);
v0.pow(2);
```

Here are some basic algebraic methods, which operate on each component of a vector:

```javascript
// component-wise math:
v0.add(v1);
v0.sub(v1);     // aka v0.subtract(v1)
v0.absdiff(v1); // the absolute difference between two vectors (always positive)
v0.mul(v1);     // aka v0.multiply(v1)
v0.div(v1);     // aka v0.divide(v1)
v0.pow(v1);        // raise v0 to the power of v1
```

There is a utility to perform linear interpolation between two vectors:

```javascript
// a linear interpolation between v0 and v1
// if t == 0, result is v0; 
// if t == 1, result is v1; 
// if t == 0.5, result is the average of v0 and v1; 
// etc. for other values of t
vec2.mix(vout, v0, v1, t);
```

There are also several useful methods for keeping vectors within bounds:

```javascript
// max retains the values that are closer to Infinity
vec2.max(vout, v0, v1);
// min retains the values that are closer to -Infinity
vec2.min(vout, v0, v1);

// lesser retains the values that are closer to zero
vec2.lesser(vout, v0, v1);
// greater retains the values that are further from zero    
vec2.greater(vout, v0, v1);

// aka clip: keeps v0 within the bounds of vlo and vhi
v0.clamp(vlo, vhi);    

// like wrap(), it gives the remainder after division
// it uses Euclidean modulo, which handles negative numbers well for toroidal space
v0.wrap(d);    

// applies wrap in a relative range, up to +d/2 and down to -d/2
// this can be useful e.g. for calculating the shortest distance between two points in toroidal space
vec2.relativewrap(vout, v0, v1);    
```

## draw2D

The ```draw2D``` namespace provides a very simple interface for drawing 2D primitives.

It uses a stack-based coordinate transform system. Push the context, apply transforms, then return back to the previous coordinate system by popping the context again:

```javascript
// create a local coordinate system:
draw2D.push();
    draw2D.translate(x, y);
    draw2D.rotate(angle_in_radians);  // or a direction vector
    draw2D.scale(sizex, sizey);

    // draw in local coordinate system
    //...

// return to global coordinate system:
draw2D.pop();
```

Most calls to draw2D can be chained together, since they return the ```draw2D``` object itself. Now typically, to move into an agent's coordinate system, operate in the order "translate, rotate, scale". So since most draw2D methods can also accept vec2 arguments, a common idiom is:

```javascript
// push into agent's local coordinate system:
draw2D.push()    
    .translate(agent.position)
    .rotate(agent.direction)
    .scale(agent.size);

    // draw agent body -- the X axis is agent's forward direction
    draw2D.rect();
    draw2D.circle([0.5,  0.5], 0.5);
    draw2D.circle([0.5, -0.5], 0.5);

draw2D.pop();  // done drawing agent
```

Basic shapes are as follows:

```javascript
draw2D.circle([center_x, center_y], diameter);
draw2D.circle(center_x, center_y, diameter);
draw2D.circle([center_x, center_y], diameter_x, diameter_y);
draw2D.circle(center_x, center_y, diameter_x, diameter_y);

draw2D.rect([center_x, center_y], diameter);
draw2D.rect(center_x, center_y, diameter);
draw2D.rect([center_x, center_y], diameter_x, diameter_y);
draw2D.rect(center_x, center_y, diameter_x, diameter_y);

draw2D.triangle([center_x, center_y], diameter);
draw2D.triangle(center_x, center_y, diameter);
draw2D.triangle([center_x, center_y], diameter_x, diameter_y);
draw2D.triangle(center_x, center_y, diameter_x, diameter_y);

draw2D.line([x1, y1], [x2, y2]);    // default thickness is 1 pixel
draw2D.line([x1, y1], [x2, y2], thickness);        
```

There's also an optimized method for when you want to draw lots of lines -- just pass in an array of points (either vec2's or arrays of two numbers). Each pair of points will make a line:

```
// draw line AB and line CD
A = new vec2(random(), random());
B = new vec2(random(), random());
C = [random(), random()];
D = [random(), random()];
draw2D.lines([A, B, C, D]);
```

If you need a different shape, there's a method for defining new ones. But this is expensive -- don't call this in ```draw()``` or ```update()```! Create an array of vertices (they could be arrays or vec2's) and pass them to the ```draw2D.shape()``` constructor; it will return a function you can use to draw your specific shape.

```javascript
// in the main body of the script (not in update() or draw()!)
// construct a new shape
// normally vertices range between -1 and 1
var rightangletriangle = draw2D.shape([ 
    new vec2(-1, -1), new vec2(1, -1), new vec2(1, 1)
]);

// use it in draw()
function draw() {
    draw2D.color("red");
    rightangletriangle();

    // it takes position/size arguments just like circle, rect, triangle:
    draw2D.color("yellow");
    rightangletriangle([0.5, 0.5], 0.25);
}
```

Graphics are drawn using whatever color is currently set, via ```draw2D.color()```. 

```javascript
draw2D.color(1, 0, 0); // red
draw2D.color(0, 1, 0); // green
draw2D.color(0, 0, 1); // blue
draw2D.color(1, 1, 1, 0.5); // semi-transparent white

// set via hue, saturation, and lightness (instead of red, green, blue)
draw2D.hsl(0.5, 0.5, 0.5);
draw2D.hsl(0.5, 0.5, 0.5, 0.5);    // semi-opaque

// you can also use standard CSS colors:
draw2D.color("#ff3399"); 
draw2D.color("red");
```

The full list of named colors is [here](http://www.w3schools.com/colors/colors_hex.asp). More color methods modify the current color:

```javascript
// set opacity (0..1):
draw2D.alpha(0.5);
draw2D.opacity(0.5);

// set hue, saturation, lightness individually:
draw2D.hue(0.5);
draw2D.saturation(0.5); 
draw2D.lightness(0.5); 

// other modulations:
draw2D.darken();
draw2D.brighten();
draw2D.saturate();
draw2D.desaturate();
```

> Note that colors are also managed by push() and pop().

It is also possible to cover the shape with a field2D, by setting it as a texture. To stop using the texture, call ```draw2D.texture()``` (with no arguments), or wrap the use of textures with ```draw2D.push()``` and ```draw2D.pop()```:

```javascript
var field = field2D(16);
field.set(function() { return random(); });

// in draw():
draw2D.push();
    draw2D.texture(field);
    draw2D.rect();
draw2D.pop();
```

Finally, we can choose whether to mix drawings additively to each other, or simply replace previous drawings, by setting the blend option:

```
draw2D.blend(true);    // mix with previous drawings
draw2D.blend(false); // replace previous drawings
```

> Note: The draw2D transform and color are reset before each ```draw()``` call.


-->
<!-- 
### Examples

- Cellular systems
    - [1D automata](http://codepen.io/grrrwaaa/pen/meVoMo)
    - [Game of Life](http://codepen.io/grrrwaaa/pen/EVPGOB)
    - [Brian's brain](http://codepen.io/grrrwaaa/pen/WQrmGb)
    - [Forest fire](http://codepen.io/grrrwaaa/pen/xwZBRP)
    - [Forest fire in colour](http://codepen.io/grrrwaaa/pen/pgrrpo)
    - [Langton's Ant](http://codepen.io/grrrwaaa/pen/RWrdoq)
    - [Multiple ants](http://codepen.io/grrrwaaa/pen/MaKxJb)
    - [Block rules](http://codepen.io/grrrwaaa/pen/NGxJpP)
    - [Reaction Diffusion](http://codepen.io/grrrwaaa/pen/RLgwWb)
    - [Ising model](http://codepen.io/grrrwaaa/pen/dGzORw)
    - [Hodgepodge](http://codepen.io/grrrwaaa/pen/LpGaxm)
    - [Semi-continuous game of life](http://codepen.io/grrrwaaa/pen/RrZgxo)
    - [Game of life + sweeper](http://codepen.io/grrrwaaa/pen/eJEegQ)
    - [Week 2 lab](http://codepen.io/grrrwaaa/pen/wMqpME)
- Agent systems
    - [Random walker](http://codepen.io/grrrwaaa/pen/mVBBPQ)
    - [Flockers](http://codepen.io/grrrwaaa/pen/LGzgpO)
    - [Flockers + obstacles](http://codepen.io/grrrwaaa/pen/XXevBb)
    - [Flockers with obstacles and predator](http://codepen.io/grrrwaaa/pen/RGXyVB?editors=0010)
    - [Simple seek/flee vehicle](http://codepen.io/grrrwaaa/pen/xZPeNV)
    - [Two-eye vehicles + environment](http://codepen.io/grrrwaaa/pen/yeKWax)
    - [As above, but with inverted speed, and collision avoidance](http://codepen.io/grrrwaaa/pen/ameRER?editors=0010)
    - [Week 3 lab](http://codepen.io/grrrwaaa/pen/LGebzj)
    - [Chemotaxis](http://codepen.io/grrrwaaa/pen/yepmvq)
    - [Chemotaxis + mouse](http://codepen.io/grrrwaaa/pen/mVxowj)
    - [Stigmergy](http://codepen.io/grrrwaaa/pen/OMvYRg)
    - [Ants (work in progress)](http://codepen.io/grrrwaaa/pen/pgVEdP)
    - [Birth & death](http://codepen.io/grrrwaaa/pen/PZxrbo)
    - [Birth & death + chemotaxis](http://codepen.io/grrrwaaa/pen/QKXaGb?editors=0010)
- Rewriting & evolutionary systems
    - [Koch curve](http://codepen.io/grrrwaaa/pen/xVVpea?editors=001)
    - [Evolving sentences](http://codepen.io/grrrwaaa/pen/yeqMYy)
    - [Evolving math](http://codepen.io/grrrwaaa/pen/zrLZvK)
    - [Evolving biomorphs](http://codepen.io/grrrwaaa/pen/yadVLP?editors=001)
    - [Evolving biomorphs (3x3)](http://codepen.io/grrrwaaa/pen/dGwWOz?editors=001)
    - [Evolving chemotaxis agents](http://codepen.io/grrrwaaa/pen/amgjbb?editors=0010)
    - [Evolving images](http://codepen.io/grrrwaaa/pen/YwmerM?editors=001)
    - [Random video feedback](http://codepen.io/grrrwaaa/pen/pyzJLe?editors=001)    
-->
<hr>
<h2 id="under-the-hood">Under the hood</h2>
<p>The library code is in <a href="https://worldmaking.github.io/code/al2019.js">GitHub here</a>.</p>

	</div>
	<footer>&copy; 2018 Graham Wakefield</footer>
  </body>
</html>