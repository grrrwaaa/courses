<!DOCTYPE html>
<html>
  <head>
	<title>WebGL quickstart</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" href="github.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="index.html" alt="index">index</a></li>
	</ul></nav>	
	<div id="main">
	<h2 id="webgl-quickstart">WebGL quickstart</h2>
<p>Introductory tutorial video:</p>
<iframe width="853" height="480" src="https://www.youtube.com/embed/rfQ8rKGTVlg?rel=0" frameborder="0" allowfullscreen></iframe>

<p>GL scenes are made out of geometry, often called &quot;meshes&quot;, which are:</p>
<ul>
<li>collections of points in space (vertices), that may also have other attributes (such as color, normal, texture coordinate...), </li>
<li>with a method for how to connect them, as points, lines or polygons (usually triangles), and typically also an indexing array (since a particular vertex may be used more than once)</li>
</ul>
<p>Most of the art of OpenGL is taking these meshes, together with textures, and sending them to the GPU with a pair of shaders to define how they will appear.</p>
<p>The general process of drawing an object is thus:</p>
<pre><code>script =&gt; uniforms + attributes =&gt; vertex shader =&gt; gl_Position, varyings
uniforms + varyings =&gt; fragment shader =&gt; gl_FragColor 
bind textures
bind buffers
draw mesh
</code></pre><p>In semi-psuedo-code:</p>
<pre><code>gl.<span class="hljs-function"><span class="hljs-title">UseProgram</span><span class="hljs-params">(shader_program)</span></span>
<span class="hljs-function"><span class="hljs-title">setupattributes</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">setupuniforms</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">bindtextures</span><span class="hljs-params">()</span></span>
gl.<span class="hljs-function"><span class="hljs-title">DrawElements</span><span class="hljs-params">(num_vertices)</span></span>
</code></pre><p>Where typically:</p>
<ul>
<li>uniforms are properties shared by a whole <em>geometry</em></li>
<li>attributes are the properties that vary <em>per vertex</em>, passed from the script as <em>buffers</em></li>
<li>vertex shader runs <em>per vertex</em></li>
<li>varyings are properties that are interpolated <em>between vertices</em></li>
<li>fragment shader runs <em>per fragment</em> (similar to <em>per pixel</em>)</li>
</ul>
<h3 id="shaders">Shaders</h3>
<p>Shaders are written in GLSL. Usually a <em>shader program</em> is a vertex shader plus a fragment shader.</p>
<p>Simplest vertex shader:</p>
<pre><code class="lang-glsl">    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"vertex_shader"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"x-shader/x-vertex"</span>&gt;</span><span class="javascript">
    attribute vec4 position;
    <span class="hljs-keyword">void</span> main() {
        gl_Position = position;
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Simplest fragment shader:</p>
<pre><code class="lang-glsl">    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"fragment_shader"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"x-shader/x-fragment"</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">void</span> main() {
        vec4 red = vec4(<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>);    <span class="hljs-comment">// RGBA</span>
        gl_Color = red;
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<pre><code>matrix_uniform = model_in_world_matrix * camer<span class="hljs-built_in">a_view</span>_matrix * camer<span class="hljs-built_in">a_projection</span>_matrix
</code></pre><h3 id="coordinate-systems">Coordinate systems</h3>
<p>Vertex shaders typically transform the position in <em>model space</em> into <em>clip space</em> by matrix multiplications, to take into account the model&#39;s pose in the world, the camera&#39;s pose in the world, and the camera perspective properties. These matrices are usually generated in JavaScript and passed in as uniforms. </p>
<ul>
<li><p><strong>Model space</strong></p>
<ul>
<li>Used by mesh position attributes. </li>
<li>Typically the origin of this space is the center or base of the mesh object</li>
</ul>
</li>
<li><p><strong>World space</strong></p>
<ul>
<li>The shared space in which all objects of the world (including the camera) are located</li>
<li>Origin and axes are fixed relative to the world</li>
</ul>
</li>
<li><p><strong>View space</strong></p>
<ul>
<li>The world space, but transformed (rotated/translated) into the view of the camera</li>
</ul>
</li>
<li><p><strong>Clip space</strong></p>
<ul>
<li>Used by <code>gl_Position</code>. </li>
<li>Always covers entire canvas from bottom-left (-1, -1) to top-right (1, 1), and depth also from -1 to 1.</li>
<li>The fourth coordinate is used for perspective division, after assignment to <code>gl_Position</code></li>
</ul>
</li>
<li><p><strong>Fragment space</strong></p>
<ul>
<li>The final location of a fragment in the canvas (or other render target), typically measured in pixels</li>
</ul>
</li>
</ul>
<p>Beside this workflow, there are other spaces that are used in OpenGL:</p>
<ul>
<li><strong>Texture space</strong><ul>
<li>Texture coordinates usually cover the source data by ranging from (0, 0) to (1, 1)</li>
<li>Also known as &quot;UV&quot; coordinates</li>
</ul>
</li>
</ul>
<h3 id="post-processing">Post-processing</h3>
<p>Also-known as multi-pass rendering. Rather than rendering directly to the screen, render to an off-screen texture, then render that texture again through another shader to process it further. Usually the vertex shader is just a pass-through drawing a single big rectangle, and all the work is in the fragment shader (screen-space effects).    </p>
<h3 id="differences-with-opengl">Differences with OpenGL</h3>
<p>Some of the significant <a href="https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#No_3D_Texture_support">differences with OpenGL</a>:</p>
<ul>
<li>Textures with non-power-of-two (NPOT) dimensions have limited support</li>
<li>No GL_DOUBLE -- this may be a problem for high-precision visualizations</li>
<li>No 3D Textures -- this <em>is</em> a problem for things like volume-rendering, common to sci-viz<ul>
<li>There are workarounds by tiling 3D slices over a 2D texture <a href="http://jsfiddle.net/greggman/gSnHZ/">example</a></li>
</ul>
</li>
</ul>
<h3 id="development-tips">Development tips</h3>
<p>Use the WebGL inspector, for <a href="https://chrome.google.com/webstore/detail/webgl-inspector/ogkcjmbhnfmlnielkjhedpcjomeaghda?hl=en">Chrome</a> or <a href="https://addons.mozilla.org/en-us/firefox/addon/webgl-inspector/">Firefox</a></p>
<p>More <a href="http://www.realtimerendering.com/blog/webgl-debugging-and-profiling-tools/">debugging &amp; development tools</a></p>
<h3 id="optimization-tips">Optimization tips</h3>
<p>Minimize updates to the GPU. Use the same shader for many objects -- set up the shader once, then draw each object. Similarly, only update the uniforms that differ between objects.</p>
<p>Do the least amount of work possible in the draw routines -- anything that is unchanged between frames move to a setup() function that runs once. </p>
<p>Move work out of JavaScript and into GLSL, especially if it is the kind of thing GLSL is really good at (vector math!). That can even mean part of the behaviour of the object itself.</p>
<p>Never call glGet** anything while rendering.</p>
<p>Possibly also merge instances into a single mesh, by storing instance-specific parameters in additional attributes.</p>
<p>Don&#39;t attach render buffers while rendering -- just set up however many framebuffers you need before starting and swap them, rather than rebuilding a renderbuffer.</p>
<p>Don&#39;t use setInterval(), use requestAnimationFrame() (so it pauses when not visible)</p>
<p>The render resolution doesn&#39;t have to be the same as the canvas resolution. Large resolutions are expensive (especially for fragment shader operations), so it can be cheaper to render at a lower resolution and stretch up (though it will be blurrier). </p>
<h2 id="three-js">Three.js</h2>
<p>Most people are using the <a href="http://threejs.org">THREE.js</a> wrapper, because raw WebGL involves a lot of repetitive fiddly work.</p>
<p><a href="http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene">Tutorial</a> </p>
<p>Basic sample:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Three.js app<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
    <span class="hljs-tag">body</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>; <span class="hljs-rule">}</span></span>
    <span class="hljs-tag">canvas</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span> </span></span></span>}
</span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-comment">&lt;!-- or &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"&gt;&lt;/script&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"three.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">

<span class="hljs-comment">// create an HTML canvas via a THREE.js renderer:</span>
<span class="hljs-keyword">var</span> canvas_width = <span class="hljs-built_in">window</span>.innerWidth;
<span class="hljs-keyword">var</span> canvas_height = <span class="hljs-built_in">window</span>.innerHeight;
<span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer();
renderer.setSize(canvas_width, canvas_height);
<span class="hljs-built_in">document</span>.body.appendChild(renderer.domElement);

<span class="hljs-comment">// create a camera:</span>
<span class="hljs-keyword">var</span> near = <span class="hljs-number">0.1</span>, far = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">var</span> aspect = canvas_width/canvas_height;
<span class="hljs-keyword">var</span> field_of_view_Y = <span class="hljs-number">75</span>;
<span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(field_of_view_Y, aspect, near, far);
camera.position.z = <span class="hljs-number">5</span>;

<span class="hljs-comment">// create a scene to hold objects:</span>
<span class="hljs-keyword">var</span> scene = <span class="hljs-keyword">new</span> THREE.Scene();

<span class="hljs-comment">// create a box:</span>
<span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> THREE.BoxGeometry( <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );
<span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial( { color: <span class="hljs-number">0x00ff00</span> } );
<span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> THREE.Mesh( geometry, material );
scene.add( cube );

<span class="hljs-comment">// simulation update:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
    cube.rotation.x += <span class="hljs-number">0.1</span>;
    cube.rotation.y += <span class="hljs-number">0.1</span>;
}

<span class="hljs-comment">// render loop:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>{
    requestAnimationFrame(render);
    update();
    renderer.render(scene, camera);
}
render();

</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre>
<p>An object&#39;s matrix stores the object&#39;s transformation relative to the object&#39;s parent (for top-level objects, the parent is the world).</p>
<p>Updating object transformation matrix, using high level position/scale/quaternion properties to update the matrix:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">position</span> =</span> start_position;
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">quaternion</span> =</span> quaternion;
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">updateMatrix</span>(</span>);
</code></pre><p>Alternatively operate on the matrix directly:</p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrixAutoUpdate</span> =</span> <span class="hljs-literal">false</span>;
<span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrix</span>.<span class="hljs-title">setRotationFromQuaternion</span>(</span>quaternion);
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrix</span>.<span class="hljs-title">setPosition</span>(</span>start_position);
</code></pre><p>If the object&#39;s parent is not the world, the world position can be requested: </p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">updateMatrixWorld</span>(</span>);
<span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrixWorld</span>;</span>
</code></pre><p>Quaternions are used for rotations, because they avoid <em>gimbal lock</em>, but you can specify with Euler Angles (object.setRotationFromEuler()) if gimbal lock will not be a problem.</p>
<h3 id="extensions">Extensions</h3>
<p><a href="http://www.threejsgames.com/extensions/">THREEx</a></p>
<h3 id="examples">Examples</h3>
<p><a href="https://stemkoski.github.io/Three.js/">https://stemkoski.github.io/Three.js/</a></p>
<h2 id="d3-in-3d">D3 in 3D</h2>

	</div>
	<footer>
		&copy; 2015 Graham Wakefield
	</footer>
  </body>
</html>