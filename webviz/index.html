<!DOCTYPE html>
<html>
  <head>
	<title>BRIDGING WEB-BASED VISUALIZATION AND 3D</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" href="github.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="d33d.html" alt="d33d">d33d</a></li>
<li><a href="index.html" alt="index">index</a></li>
	</ul></nav>	
	<div id="main">
	<h1 id="bridging-web-based-visualization-and-3d">BRIDGING WEB-BASED VISUALIZATION AND 3D</h1>
<p><a href="http://www.canvas2015.ca">http://www.canvas2015.ca</a></p>
<p>Web-based technologies</p>
<ul>
<li>Super accessible, nothing to install</li>
<li>Modern browsers support rich graphics, audio, high performance</li>
<li>HTML, CSS, JS:<ul>
<li>HTML the original markup language of the web. Static, tree-like document structure (DOM)<ul>
<li>now also includes vector graphics (SVG, Canvas), video, etc.</li>
</ul>
</li>
<li>CSS defines &#39;styles&#39; we can apply to HTML, richer set of layout &amp; appearance attributes</li>
<li>JavaScript is the dynamic part<ul>
<li>A full-fledged high-level programming language, with incredibly fast implementations</li>
<li>Masses of JS libraries out there.</li>
<li>Can also write servers using JS (via Node.js)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>An exciting recent development is WebGL, a mostly-compatible port of the standardized, GPU-accelerated 3D graphics library OpenGL to JavaScript/HTML5 canvas. An even more recent extension is WebVR, meaning that browser-based visualizations will be a URL away for owners of Oculus Rift etc. Immersive live information visualization may suddenly be within reach of millions. Untrod land... an interesting research area!</p>
<p>D3.js</p>
<ul>
<li>very widely used, mature data viz library.</li>
<li>core concept, let data drive the DOM. <ul>
<li>Can be basic HTML, but usually SVG graphics. Lines, rects, circles, text, beziers, etc. 2D</li>
</ul>
</li>
<li>utilities for reading data from external sources (e.g. open data APIs, CSV/JSON files)</li>
<li>generate a selection from the data, and set its attributes to viz</li>
<li>enter/update/exit for dynamic data selections</li>
<li>transitions for animated changes</li>
<li>utilities for array analysis, scaling and quantizing, etc.</li>
<li>force-driven graphs and many other classic viz examples</li>
<li>2D</li>
</ul>
<p>D3 live example: currency scatterplot</p>
<ul>
<li>We&#39;ll use some data I prepared earlier, drawn from an open data resource (rather than hammering the servers every time we edit!)</li>
<li>We&#39;ll use <a href="http://codepen.io">Codepen.io</a> to build our demo. This is a live browser-based HTML/CSS/JS editor, which means we can work without needing to install anything.</li>
<li>D3.js, currencies.json</li>
<li></li>
</ul>
<p><a href="http://codepen.io/anon/pen/YXRXZb?editors=001">http://codepen.io/anon/pen/YXRXZb?editors=001</a></p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> canvas_width = <span class="hljs-built_in">window</span>.innerWidth;
    <span class="hljs-keyword">var</span> canvas_height = <span class="hljs-built_in">window</span>.innerHeight;

    <span class="hljs-comment">// create an SVG canvas:</span>
    svg = d3.select(<span class="hljs-string">'body'</span>)
            .append(<span class="hljs-string">'svg'</span>)
            .attr(<span class="hljs-string">'width'</span>, <span class="hljs-built_in">window</span>.innerWidth)
            .attr(<span class="hljs-string">'height'</span>, <span class="hljs-built_in">window</span>.innerHeight);

    <span class="hljs-comment">// get the basic data resource:</span>
    <span class="hljs-keyword">var</span> data = currencies.history;

    <span class="hljs-comment">// create linear mappings from the data domain (min, max) to the canvas size:</span>
    <span class="hljs-keyword">var</span> xScale = d3.scale.linear()
            .domain([d3.min(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.EUR;
            }), d3.max(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.EUR;
            })])
            .range([<span class="hljs-number">0</span>, canvas_width]);

    <span class="hljs-keyword">var</span> yScale = d3.scale.linear()
            .domain([d3.min(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.GBP;
            }), d3.max(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.GBP;
            })])
            .range([canvas_height, <span class="hljs-number">0</span>]);    <span class="hljs-comment">// note Y range is upside down</span>

    <span class="hljs-comment">// another linear mapping for circle radius:</span>
    <span class="hljs-keyword">var</span> rScale = d3.scale.linear()
            .domain([d3.min(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.CAD;
            }), d3.max(data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> d.rates.CAD;
            })])
            .range([<span class="hljs-number">1</span>, <span class="hljs-number">8</span>]);

    <span class="hljs-comment">// plot circles for each entity:</span>
    svg.selectAll(<span class="hljs-string">"circle"</span>)
            .data(data)
            .enter()
            .append(<span class="hljs-string">"circle"</span>)
            .attr(<span class="hljs-string">"cx"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> xScale(d.rates.EUR);
            })
            .attr(<span class="hljs-string">"cy"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> yScale(d.rates.GBP);
            })
            .attr(<span class="hljs-string">"r"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d)</span> </span>{
                    <span class="hljs-keyword">return</span> rScale(d.rates.CAD);
            })
            .attr(<span class="hljs-string">"fill"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d, i)</span> </span>{
                    h = <span class="hljs-number">360</span> * i / data.length;
                    <span class="hljs-keyword">return</span> d3.hsl(h, <span class="hljs-number">0.85</span>, <span class="hljs-number">0.65</span>);
            })
            .attr(<span class="hljs-string">"stroke"</span>, <span class="hljs-string">"black"</span>);
</code></pre>
<p>WebGL</p>
<ul>
<li>geometry (buffers), images (textures), vertex transformation and pixel-coloring programs (shaders). Journey of a vertex from object space to screen space.</li>
<li>close to original OpenGL, i.e. verbose, fiddly, and arcane API, including another required sub-language (GLSL).</li>
</ul>
<p>Three.js</p>
<p>Most people are using the <a href="http://threejs.org">THREE.js</a> wrapper, because raw WebGL involves a lot of repetitive fiddly work. </p>
<p><a href="http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene">Three.js tutorial</a></p>
<pre><code class="lang-html">    <span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>My first Three.js app<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">style</span>&gt;</span><span class="css">
                <span class="hljs-tag">body</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>; <span class="hljs-rule">}</span></span>
                <span class="hljs-tag">canvas</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">100%</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">height</span>:<span class="hljs-value"> <span class="hljs-number">100%</span> </span></span></span>}
            </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"js/three.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
                <span class="hljs-keyword">var</span> scene = <span class="hljs-keyword">new</span> THREE.Scene();
                <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera( <span class="hljs-number">75</span>, <span class="hljs-built_in">window</span>.innerWidth/<span class="hljs-built_in">window</span>.innerHeight, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span> );

                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer();
                renderer.setSize( <span class="hljs-built_in">window</span>.innerWidth, <span class="hljs-built_in">window</span>.innerHeight );
                <span class="hljs-built_in">document</span>.body.appendChild( renderer.domElement );

                <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> THREE.BoxGeometry( <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );
                <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial( { color: <span class="hljs-number">0x00ff00</span> } );
                <span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> THREE.Mesh( geometry, material );
                scene.add( cube );

                camera.position.z = <span class="hljs-number">5</span>;

                <span class="hljs-keyword">var</span> render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
                    requestAnimationFrame( render );

                    cube.rotation.x += <span class="hljs-number">0.1</span>;
                    cube.rotation.y += <span class="hljs-number">0.1</span>;

                    renderer.render(scene, camera);
                };

                render();
            </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<blockquote>
<p>Watch out: an annoying thing about three.js is that, despite being very widely used, it is still officially in alpha and there have been many API changes -- there&#39;s a good chance that code you find on the web won&#39;t work with newer versions of the library.</p>
</blockquote>
<p>A renderer needs a scene and a camera to paint a canvas, at up to 60 frames per second.</p>
<p>The camera handles the perspective, including depth cues of foreshortening (unless an orthographic camera is used). Typically we want some kind of navigation control (world-in-hand or flying/walking) to move and orient the camera. For now we&#39;ll use the OrbitControls example supplied by Three.js, which is a kind of world-in-hand navigation.</p>
<p>A scene is a a hierarchical tree of nodes, the leaves of which are &quot;meshes&quot;. A mesh is a geometry plus a material. We&#39;ll inject D3 into the process of managing the scene of meshes, via some <a href="http://codepen.io/anon/pen/BNGaeP?editors=011">glue code</a>. </p>
<p>Our scene will look like this:</p>
<ul>
<li>scene<ul>
<li>lights</li>
<li>chart3d<ul>
<li>grid lines</li>
<li>box nodes (the data entities)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Geometry: primitive cubes, spheres, planes etc., geometry loaded from 3D model assets, geometry extruded from text, arbitrary geometry from data/algorithms, etc. Geometry is basically an array of 3D vertex positions with other attributes (normals, texture coordinates, etc.)  These are pushed through a shader program (written in GLSL) to define how the intermediate surfaces are painted. With Three.js we don&#39;t have to think about shader programs much, we can just use the built-in <em>materials</em>, where MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial are the most common cases.</p>
<p>Most materials require that we add some lights to our scene. For 3D info viz top left/top right lights are the most appropriate. Lights might also need to track the camera.</p>
<p>We&#39;ll generate grid lines as another kind of mesh, using D3&#39;s <code>scale</code> mapping generators to simplify and automate the process, and to reposition the chart into the center of the world, etc.</p>
<p>Rather than adding text labels into the 3D world, we&#39;ll demonstrate a head-up-display using SVG overlaid on top of the WebGL canvas. We create an array of labels and let D3 render them, after Three.js projects the 3D world position into a 2D pixel position.</p>
<p>We also show how to go the other way, to take a mouse pixel coordinate and select the 3D object underneath it, to add another text overlay.</p>
<p>We demonstrate the classic D3 enter/update/exit cycle for dynamically showing subsets of points, and animating transitions. </p>
<p>We also show a few other niceties along the way.</p>
<p><a href="http://codepen.io/anon/pen/RPqwmj?editors=001">Here&#39;s the currency scatterplot in 3D</a></p>
<h1 id="bridging-data-viz-and-3d-web">Bridging data viz and 3D web</h1>
<p><a href="http://codepen.io/anon/pen/MwXNWm?editors=101">Currency demo</a></p>
<h2 id="webgl-quickstart">WebGL quickstart</h2>
<p>Introductory tutorial video:</p>
<iframe width="853" height="480" src="https://www.youtube.com/embed/rfQ8rKGTVlg?rel=0" frameborder="0" allowfullscreen></iframe>

<p>GL scenes are made out of geometry, often called &quot;meshes&quot;, which are:</p>
<ul>
<li>collections of points in space (vertices), that may also have other attributes (such as color, normal, texture coordinate...), </li>
<li>with a method for how to connect them, as points, lines or polygons (usually triangles), and typically also an indexing array (since a particular vertex may be used more than once)</li>
</ul>
<p>Most of the art of OpenGL is taking these meshes, together with textures, and sending them to the GPU with a pair of shaders to define how they will appear.</p>
<p>The general process of drawing an object is thus:</p>
<pre><code>    <span class="hljs-variable">script =</span>&gt; uniforms + <span class="hljs-variable">attributes =</span>&gt; vertex <span class="hljs-variable">shader =</span>&gt; gl_Position, varyings
    uniforms + <span class="hljs-variable">varyings =</span>&gt; fragment <span class="hljs-variable">shader =</span>&gt; gl_FragColor 
    bind textures&lt;span <span class="hljs-variable">class=</span><span class="hljs-string">"hljs-function"</span>&gt;
    bind buffers
    draw mesh
</code></pre><p>In semi-psuedo-code:</p>
<pre><code>    gl.<span class="hljs-function"><span class="hljs-title">UseProgram</span><span class="hljs-params">(shader_program)</span></span>
    <span class="hljs-function"><span class="hljs-title">setupattributes</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-title">setupuniforms</span><span class="hljs-params">()</span></span>
    <span class="hljs-function"><span class="hljs-title">bindtextures</span><span class="hljs-params">()</span></span>
    gl.<span class="hljs-function"><span class="hljs-title">DrawElements</span><span class="hljs-params">(num_vertices)</span></span>
</code></pre><p>Where typically:</p>
<ul>
<li>uniforms are properties shared by a whole <em>geometry</em></li>
<li>attributes are the properties that var</h3>y <em>per vertex</em>, passed from the script as <em>buffers</em></li>
<li>vertex shader runs <em>per vertex</em></li>
<li>varyings are properties that are interpolated <em>between vertices</em></li>
<li>fragment shader runs <em>per fragment</em> (similar to <em>per pixel</em>)</li>
</ul>
<h3 id="shaders">Shaders</h3>
<p>Shaders are written in GLSL. Usually a <em>shader program</em> is a vertex shader plus a fragment shader.</p>
<p>Simplest vertex shader:</p>
<pre><code class="lang-glsl">    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"vertex_shader"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"x-shader/x-vertex"</span>&gt;</span><span class="javascript">
    attribute vec4 position;
    <span class="hljs-keyword">void</span> main() {
        gl_Position = position;
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Simplest fragment shader:</p>
<pre><code class="lang-glsl">    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"fragment_shader"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"x-shader/x-fragment"</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">void</span> main() {
        vec4 red = vec4(<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>);    <span class="hljs-comment">// RGBA</span>
        gl_Color = red;
    }
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<h3 id="coordinate-systems">Coordinate systems</h3>
<p>Vertex shaders typically transform the position in <em>model space</em> into <em>clip space</em> by matrix multiplications, to take into account the model&#39;s pose in the world, the camera&#39;s pose in the world, and the camera perspective properties. These matrices are usually generated in JavaScript and passed in as uniforms. </p>
<ul>
<li><p><strong>Model space</strong></p>
<ul>
<li>Used by mesh position attributes. </li>
<li>Typically the origin of this space is the center or base of the mesh object</li>
</ul>
</li>
<li><p><strong>World space</strong></p>
<ul>
<li>The shared space in which all objects of the world (including the camera) are located</li>
<li>Origin and axes are fixed relative to the world</li>
</ul>
</li>
<li><p><strong>View space</strong></p>
<ul>
<li>The world space, but transformed (rotated/translated) into the view of the camera</li>
</ul>
</li>
<li><p><strong>Clip space</strong></p>
<ul>
<li>Used by <code>gl_Position</code>. </li>
<li>Always covers entire canvas from bottom-left (-1, -1) to top-right (1, 1), and depth also from -1 to 1.</li>
<li>The fourth coordinate is used for perspective division, after assignment to <code>gl_Position</code></li>
</ul>
</li>
<li><p><strong>Fragment space</strong></p>
<ul>
<li>The final location of a fragment in the canvas (or other render target), typically measured in pixels</li>
</ul>
</li>
</ul>
<p>Beside this workflow, there are other spaces that are used in OpenGL:</p>
<ul>
<li><strong>Texture space</strong><ul>
<li>Texture coordinates usually cover the source data by ranging from (0, 0) to (1, 1)</li>
<li>Also known as &quot;UV&quot; coordinates</li>
</ul>
</li>
</ul>
<pre><code>    matrix_uniform = model_in_world_matrix * camer<span class="hljs-built_in">a_view</span>_matrix * camer<span class="hljs-built_in">a_projection</span>_matrix
</code></pre><h3 id="post-processing">Post-processing</h3>
<p>Also-known as multi-pass rendering. Rather than rendering directly to the screen, render to an off-screen texture, then render that texture again through another shader to process it further. Usually the vertex shader is just a pass-through drawing a single big rectangle, and all the work is in the fragment shader (screen-space effects).    </p>
<h3 id="differences-with-opengl">Differences with OpenGL</h3>
<p>Some of the significant <a href="https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#No_3D_Texture_support">differences with OpenGL</a>:</p>
<ul>
<li>Textures with non-power-of-two (NPOT) dimensions have limited support</li>
<li>No GL_DOUBLE -- this may be a problem for high-precision visualizations</li>
<li>No 3D Textures -- this <em>is</em> a problem for things like volume-rendering, common to sci-viz<ul>
<li>There are workarounds by tiling 3D slices over a 2D texture <a href="http://jsfiddle.net/greggman/gSnHZ/">example</a></li>
</ul>
</li>
</ul>
<h3 id="development-tips">Development tips</h3>
<p>Use the WebGL inspector, for <a href="https://chrome.google.com/webstore/detail/webgl-inspector/ogkcjmbhnfmlnielkjhedpcjomeaghda?hl=en">Chrome</a> or <a href="https://addons.mozilla.org/en-us/firefox/addon/webgl-inspector/">Firefox</a></p>
<p>More <a href="http://www.realtimerendering.com/blog/webgl-debugging-and-profiling-tools">debugging &amp; development tools</a></p>
<h3 id="optimization-tips">Optimization tips</h3>
<p>Minimize updates to the GPU. Use the same shader for many objects -- set up the shader once, then draw each object. Similarly, only update the uniforms that differ between objects.</p>
<p>Do the least amount of work possible in the draw routines -- anything that is unchanged between frames move to a setup() function that runs once. </p>
<p>Move work out of JavaScript and into GLSL, especially if it is the kind of thing GLSL is really good at (vector math!). That can even mean part of the behaviour of the object itself.</p>
<p>Never call glGet** anything while rendering.</p>
<p>Possibly also merge instances into a single mesh, by storing instance-specific parameters in additional attributes.</p>
<p>Don&#39;t attach render buffers while rendering -- just set up however many framebuffers you need before starting and swap them, rather than rebuilding a renderbuffer.</p>
<p>Don&#39;t use setInterval(), use requestAnimationFrame() (so it pauses when not visible)</p>
<p>The render resolution doesn&#39;t have to be the same as the canvas resolution. Large resolutions are expensive (especially for fragment shader operations), so it can be cheaper to render at a lower resolution and stretch up (though it will be blurrier). </p>
<h2 id="three-js">Three.js</h2>
<p>Most people are using the <a href="http://threejs.org">THREE.js</a> wrapper, because raw WebGL involves a lot of repetitive fiddly work.</p>
<p><a href="http://threejs.org/docs/index.html#Manual/Introduction/Creating_a_scene">Tutorial</a> </p>
<p>Basic sample:</p>
<pre><code class="lang-html">    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;Three.js app&lt;/title&gt;
    &lt;style&gt;&lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"css"</span>&gt;
        body &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rules"</span>&gt;{ &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rule"</span>&gt;margin: <span class="hljs-number">0</span>; &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rule"</span>&gt;}
        canvas &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rules"</span>&gt;{ &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rule"</span>&gt;width: <span class="hljs-number">100</span>%; &lt;span <span class="hljs-keyword">class</span>=<span class="hljs-string">"hljs-rule"</span>&gt;height: <span class="hljs-number">100</span>% }
    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;!-- or &lt;script src=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"</span>&gt;&lt;/script&gt; --&gt;
    &lt;script src=<span class="hljs-string">"three.min.js"</span>&gt;&lt;/script&gt;
    &lt;script&gt;

    <span class="hljs-comment">// create an HTML canvas via a THREE.js renderer:</span>
    <span class="hljs-keyword">var</span> canvas_width = &lt;span window.innerWidth;
    <span class="hljs-keyword">var</span> canvas_height = &lt;span window.innerHeight;
    <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">new</span> THREE.WebGLRenderer();
    renderer.setSize(canvas_width, canvas_height);
    &lt;span document.body.appendChild(renderer.domElement);

    <span class="hljs-comment">// create a camera:</span>
    <span class="hljs-keyword">var</span> near = <span class="hljs-number">0.1</span>, far = <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">var</span> aspect = canvas_width/canvas_height;
    <span class="hljs-keyword">var</span> field_of_view_Y = <span class="hljs-number">75</span>;
    <span class="hljs-keyword">var</span> camera = <span class="hljs-keyword">new</span> THREE.PerspectiveCamera(field_of_view_Y, aspect, near, far);
    camera.position.z = <span class="hljs-number">5</span>;

    <span class="hljs-comment">// create a scene to hold objects:</span>
    <span class="hljs-keyword">var</span> scene = <span class="hljs-keyword">new</span> THREE.Scene();

    <span class="hljs-comment">// create a box:</span>
    <span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> THREE.BoxGeometry( <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> );
    <span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial( { color: <span class="hljs-number">0x00ff00</span> } );
    <span class="hljs-keyword">var</span> cube = <span class="hljs-keyword">new</span> THREE.Mesh( geometry, material );
    scene.add( cube );

    <span class="hljs-comment">// simulation update:</span>
    <span class="hljs-function">function <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
        cube.rotation.x += <span class="hljs-number">0.1</span>;
        cube.rotation.y += <span class="hljs-number">0.1</span>;
    }

    <span class="hljs-comment">// render loop:</span>
    <span class="hljs-function">function <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>{
        requestAnimationFrame(render);
        update();
        renderer.render(scene, camera);
    }
    render();

    &lt;/script&gt;
    &lt;/body&gt;
</code></pre>
<p>An object&#39;s matrix stores the object&#39;s transformation relative to the object&#39;s parent (for top-level objects, the parent is the world).</p>
<p>Updating object transformation matrix, using high level position/scale/quaternion properties to update the matrix:</p>
<pre><code>    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">position</span> =</span> start_position;
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">quaternion</span> =</span> quaternion;
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">updateMatrix</span>(</span>);
</code></pre><p>Alternatively operate on the matrix directly:</p>
<pre><code>    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrixAutoUpdate</span> =</span> &lt;span <span class="hljs-class"><span class="hljs-keyword">class</span>=</span><span class="hljs-string">"hljs-literal"</span>&gt;<span class="hljs-literal">false</span>;
<span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrix</span>.<span class="hljs-title">setRotationFromQuaternion</span>(</span>quaternion);
    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrix</span>.<span class="hljs-title">setPosition</span>(</span>start_position);
</code></pre><p>If the object&#39;s parent is not the world, the world position can be requested: </p>
<pre><code>    <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">updateMatrixWorld</span>(</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">object</span>.<span class="hljs-title">matrixWorld</span>;</span>
</code></pre><p>Quaternions are used for rotations, because they avoid <em>gimbal lock</em>, but you can specify with Euler Angles (object.setRotationFromEuler()) if gimbal lock will not be a problem.</p>
<h3 id="extensions">Extensions</h3>
<p><a href="http://www.threejsgames.com/extensions">THREEx</a></p>
<h3 id="examples">Examples</h3>
<p><a href="https://stemkoski.github.io/Three.js/">https://stemkoski.github.io/Three.js/</a></p>

	</div>
	<footer>
		&copy; 2015 Graham Wakefield
	</footer>
  </body>
</html>