<!DOCTYPE html>
<html>
  <head>
	<title>D3 in 3D</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
	<link rel="stylesheet" href="github.css" type="text/css" />
  </head>
  <body>
  	<nav>
	<ul>
	<li><a href="d33d.html" alt="d33d">d33d</a></li>
<li><a href="index.html" alt="index">index</a></li>
	</ul></nav>	
	<div id="main">
	<h1 id="d3-in-3d">D3 in 3D</h1>
<p>With <em>D3</em> being one of the most acclaimed data visualization libraries for the web, and <em>three.js</em> being probably the widest-used programming interface to WebGL, it seems natural to combine them for 3D visualizations. </p>
<p>It&#39;s not so easy however. D3 operates on the HTML DOM (Document Object Model) itself, either by manipluating regular DOM elements such as <code>&lt;div&gt;</code>, or by manipulating graphical DOM elements created using SVG (Scalable Vector Graphics). But WebGL is entirely contained within a single <code>&lt;canvas&gt;</code> tag, and its 3D objects are not part of the DOM. </p>
<p><strong>Glue:</strong> Fortunately, <a href="http://grrrwaaa.github.io/courses/webviz/d33d.js">with a bit of glue code</a>, we can extend Three.js&#39;s <code>Object3D</code> prototype to &quot;look like&quot; a DOM node. </p>
<blockquote>
<p>The glue code provides <code>Object3D</code> with all the method names D3 expects to find in DOM nodes, but implements them in terms of changes to a 3D WebGL scene. Since <code>Object3D</code> is the base class of most of three.js&#39;s 3D objects, this means we can use D3&#39;s great data handling, data binding, and transitions work with 3D scenes.</p>
</blockquote>
<p>Here are some examples that show the D3 and 3D versions side by side:</p>
<ul>
<li><a href="http://codepen.io/anon/pen/rVqqOp?editors=001">A simple bar chart</a></li>
<li><a href="http://codepen.io/anon/pen/dommMg?editors=001">A variation of D3&#39;s General Update Pattern example</a></li>
<li><a href="http://codepen.io/anon/pen/RPqwmj?editors=001">Currency scatterplot</a></li>
</ul>
<h2 id="data-driven-objects">Data-driven objects</h2>
<p>We may want to group data-driven objects under a container node, so that they can be transformed en-masse, rather than adding them directly to the <code>scene</code> root:</p>
<pre><code class="lang-javascript">    // <span class="hljs-operator"><span class="hljs-keyword">create</span> container node <span class="hljs-keyword">for</span> our <span class="hljs-keyword">data</span>-driven objects:
    <span class="hljs-keyword">var</span> chart3d = new THREE.Object3D();</span>
    scene.add(chart3d);
</code></pre>
<p>Now rather than adding objects to <code>chart3d</code> directly with <code>chart3d.add(myobject)</code>, we&#39;re going to use D3&#39;s update pattern to do this automatically.</p>
<h2 id="creating-3d-nodes">Creating 3D nodes</h2>
<p>Whereas with SVG we have a set of predefined shape nodes, such as <code>rect</code>, <code>circle</code>, etc., for our 3D graphs we are going to need to define new node type constructors. To do this, we wrap our our object creation code in a function that takes data (and data-index) parameters. Here&#39;s an example using a red box of unit size, whose color depends on a data element:</p>
<pre><code class="lang-javascript">    function makeBox(<span class="hljs-typedef"><span class="hljs-keyword">data</span>, index) <span class="hljs-container">{
      <span class="hljs-title">return</span> <span class="hljs-title">new</span> <span class="hljs-type">THREE</span>.<span class="hljs-type">Mesh</span>(
        <span class="hljs-title">new</span> <span class="hljs-type">THREE</span>.<span class="hljs-type">BoxGeometry</span>(0.5, 0.5, 0.5),    // 0.5 "<span class="hljs-title">radius</span>"
        <span class="hljs-title">new</span> <span class="hljs-type">THREE</span>.<span class="hljs-type">MeshLambertMaterial</span>({ <span class="hljs-title">color</span>: <span class="hljs-title">data</span>.<span class="hljs-title">color</span> }</span>);</span>
      );
    }
</code></pre>
<p>Creating new geometry and materials for each node is wasteful if they are all the same. For example, if all nodes are cubes, we can define the geometry once and re-use it. Similarly, we can define a default material, and clone it per instance. (If we didn&#39;t clone it, then changing the colour of one box would change the colours of all boxes. The same would hold true for geometry, if this was data-driven.) So our constructor is more likely to look like this:</p>
<pre><code class="lang-javascript">    <span class="hljs-keyword">var</span> box_geometry = <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">var</span> default_material = <span class="hljs-keyword">new</span> THREE.MeshLambertMaterial();

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeBox</span><span class="hljs-params">(data, index)</span> </span>{
        <span class="hljs-keyword">var</span> material = default_material.<span class="hljs-keyword">clone</span>();
        material.color.setHex(data.color);
         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> THREE.Mesh(box_geometry, material);
    }
</code></pre>
<p>We might also want to transform the geometry before adding it. For example, we might want the anchor point (pivot point) to be a corner of the box, rather than the center. This can be done by applying a transformation to the mesh geometry, for example:</p>
<pre><code class="lang-javascript">    box_geometry.applyMatrix( <span class="hljs-keyword">new</span> <span class="hljs-type">THREE</span>.<span class="hljs-type">Matrix4</span><span class="hljs-literal">()</span>.makeTranslation( <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span> ) );
</code></pre>
<h2 id="filling-the-chart">Filling the chart</h2>
<p>Now we can use D3&#39;s typical commands to add 3D boxes to our chart, with only a few small variations:</p>
<ul>
<li><code>select(chart3d)</code> instead of <code>select(svgelement)</code></li>
<li><code>selectAll(&quot;THREE.Mesh&quot;)</code> instead of <code>select(&quot;rect&quot;)</code> etc. </li>
<li>after binding data, append using our constructor function defined above instead of appending <code>&quot;rect&quot;</code> etc. </li>
<li>the set of attributes we can set are different for 3D objects</li>
</ul>
<pre><code class="lang-javascript">    d3.select(chart3d)                            // instead <span class="hljs-keyword">of</span> svg    
      .selectAll(<span class="hljs-string">"THREE.Mesh"</span>)                    // instead <span class="hljs-keyword">of</span> <span class="hljs-string">"rect"</span> etc.
      .<span class="hljs-typedef"><span class="hljs-keyword">data</span><span class="hljs-container">(<span class="hljs-title">data</span>)</span>                                </span>
      .enter()
          .append(makeBox)                        // instead <span class="hljs-keyword">of</span> <span class="hljs-string">"rect"</span> etc.
          .attr(<span class="hljs-string">"position.x"</span>, function(d, i) {    // instead <span class="hljs-keyword">of</span> <span class="hljs-string">"x"</span>
              return d.x;
          })
</code></pre>
<h2 id="setting-and-animating-attributes-calling-methods">Setting and animating attributes, calling methods</h2>
<p>The attributes we can set on a data-driven element depend on the type of the element. In SVG rendering, &quot;rect&quot; gives us &quot;x&quot;, &quot;y&quot;, &quot;width&quot;, &quot;height&quot;, &quot;fill&quot;, &quot;stroke&quot;, etc.  For <code>&quot;THREE.Mesh&quot;</code> objects we have:</p>
<ul>
<li>&quot;position.x&quot;, &quot;position.y&quot;, &quot;position.z&quot;</li>
<li>&quot;rotation.x&quot;, &quot;rotation.y&quot;, &quot;rotation.z&quot; (Euler angles; can also set &quot;quaternion.x&quot; etc.)</li>
<li>&quot;scale.x&quot;, &quot;scale.y&quot;, &quot;scale.z&quot;</li>
<li>&quot;visible&quot; (true/false)</li>
</ul>
<p>Material properties can also be changed -- but be sure that the constructor creates a unique or cloned material per instance:</p>
<ul>
<li>&quot;material.color.r&quot;, &quot;material.color.g&quot;, &quot;material.color.b&quot; (all 0-1 range)</li>
<li>&quot;material.transparent&quot; (true/false)</li>
<li>&quot;material.opacity&quot; (0-1, only if material.transparent == true)</li>
<li><a href="http://threejs.org/docs/#Reference/Materials/Material">see also</a></li>
</ul>
<p>The great thing about setting selection attributes is that they can be animated by D3&#39;s transitions. </p>
<p>To call methods of Object3D, use the <code>.each()</code> method of the selection. Unlike attribute modification, this won&#39;t interpolate during transitions.</p>
<pre><code class="lang-javascript">    .<span class="hljs-keyword">each</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(d, i)</span> </span>{
        <span class="hljs-comment">// 'this' refers to the THREE.Mesh    </span>
        <span class="hljs-keyword">this</span>.translateZ(-<span class="hljs-number">1</span>);
    })
</code></pre>
<h2 id="making-labels">Making labels</h2>
<p>There are several ways to incorporate text into WebGL, depending on how 3D we really want them.</p>
<ul>
<li>As 3D geometry, where fonts are extruded into 3D shapes. This is not usually relevant to data visualizations.</li>
<li>As text &#39;sprites&#39; actually placed in the 3D world: plane geometries on which the text is textured, which always face the camera, and which are embedded in the 3D scene. The text itself can be rendered by using an off-screen HTML5 Canvas2D, and brought into THREE.js with a bit of extra code. Should be faster than option 1 because of the simpler geometry; and more readable.</li>
<li>As a 2D text overlaid above the 3D scene (like a HUD: head-up display). This is relatively easily done via HTML, SVG, or Canvas2D. HTML/SVG means we can also use D3 to do this. However there is no occlusion or distance-scaling here. It requires a bit of code to extract the 2D pixel location of a 3D object.</li>
</ul>
<p><a href="http://codepen.io/anon/pen/mJzZBw?editors=001">http://codepen.io/anon/pen/mJzZBw?editors=001</a></p>
<h3 id="camera">Camera</h3>
<p>An orthographic camera may be more appropriate to data visualization, as it preserves the meaning of screen-space distance regardless of depth. </p>
<p>Conversely, a perspective camera may be preferable for stereoscopic and immersive visualizations, or any visualization intended to be &#39;navigable&#39;, where perspective grants focus and context.</p>
<p>A scene may be better understood by utilizing multiple cameras, whether side-by-side or picture-in-picture.</p>
<h3 id="interaction">Interaction</h3>
<p>Mouse interaction is trickier in 3D. A 3D scene is not a simple pixel space like in D3. We need to push the mouse coordinates through the inverse transform of the renderer, by projecting it as a ray from the camera, to see what it hits.</p>
<p>THREE.js makes this fairly easy with a RayCaster object.</p>
<h3 id="grids">Grids</h3>
<p><a href="http://codepen.io/anon/pen/mJzZBw?editors=001">http://codepen.io/anon/pen/mJzZBw?editors=001</a></p>
<h3 id="performance">Performance</h3>
<p>Basically, use <code>requestAnimationFrame()</code> to do most of the work -- including modifications to the data set that drive scene changes. This makes sure the animation is not using resources when not being viewed. (In contrast, <code>SetInterval()</code> is always running, and should only be used when absolutely necessary.)</p>

	</div>
	<footer>
		&copy; 2015 Graham Wakefield
	</footer>
  </body>
</html>