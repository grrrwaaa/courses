<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <script src="al.js"></script>
    <script>
var dim = 200;	// the field resolution    

var max_speed = 1/400;
var max_steer = 0.1;
var max_population = 500;

var metabolism_cost = 0.01;
var reproduction_threshold = 2;
var agents = [];
var initial_population_size = 10;
var digestion_efficiency = 0.1;

var world_energy = dim*dim*0.25;

var food_diffusion = 0.001;

var sensor_size = 0.5;

// used for double-buffering the agent population
// (for safe insertion & removal while traversing)
var newagents = [];

// initialize a field of food:
var food = new field2D(dim);
var food_back = food.clone();
food.set(function() { return random(2); });
food.diffuse(food, 10);
food.normalize().mul(0.45);


function agent_new() {
  return {
    size: 0.01,
    mass: 1,
    hue: random(),
    pos: new vec2(random(), random()),
    dir: random() * Math.PI * 2,
    vel: vec2.random(max_speed),
    // states (also senses)
    age: 0,
    energy: random(),
    // senses:
    sensor: new vec2(),
    food: 0,
    // outputs:
    wheel_rate: new vec2(random(), random()),
    eat_rate: 1,
  }
}	

// initialize a population:
for (var i=0; i<initial_population_size; i++) {
  agents.push(agent_new());
}

// implement the locomotion model:
function agent_locomotion(a) {
  // limit to 0..1 range (no backpedaling):
  a.wheel_rate.clip(1); 
  // convert wheel rates to velocity:
  var steer = a.wheel_rate[0] - a.wheel_rate[1];
  a.dir += steer * max_steer;
  var speed = (a.wheel_rate[0] + a.wheel_rate[1]) * 0.5;
  var vel = vec2.fromPolar(speed * max_speed, a.dir);
  // compute acceleration, as force applied
  // subtract this from energy store as effort/work done
  var force = a.vel.sub(vel).mag() * a.mass;
  a.energy -= force;
  // update velocity:
  a.vel = vel;
  // apply to position:
  a.pos.add(a.vel).wrap(1);
}

function agent_eating(a) {
	// eating:
	var f = Math.max(0, food.sample(a.pos));
	// scale by eat_rate (clamped in 0..1)
    var f = f * Math.max(Math.min(1, (0, a.eat_rate)));
    // remove from world:
    food.deposit(-f, a.pos);
    // add to agent:
    a.energy += f * digestion_efficiency;
}

// detect the environment:
function agent_sensing(a) {
  // TODO: add additional sensors here
  
  // get sensor locations in world-space:
    var sensor1 = new vec2(sensor_size, sensor_size).mul(a.size).rotate(a.dir).add(a.pos);
    var sensor2 = new vec2(sensor_size, -sensor_size).mul(a.size).rotate(a.dir).add(a.pos);
  // get food concentration at these locations:
  a.sensor[0] = food.sample(sensor1);
  a.sensor[1] = food.sample(sensor2);
  a.food = food.sample(a.pos);
}
 
// decision-making:
function agent_process(a) {
  // TODO: this should be genetically-determined
  // TODO: limit *change* of wheel rates?
  //a.wheel_rate.set( Math.sin(now), Math.cos(now * 3));
  var v1 = 1-a.food;
  var v2 = (a.sensor[1] - a.sensor[0])*3;
  a.wheel_rate[0] = v1-v2;
  a.wheel_rate[1] = v1+v2;
}


function update() {
  write("time:", now);
  
  var tmp = food_back;
  food_back = food;
  food = food_back;
  food.diffuse(food_back, food_diffusion);
  
  newagents = [];
  
  // simulation code here
  for (var a of agents) {
      a.age += dt;
      a.energy -= metabolism_cost * a.mass;
      
      agent_sensing(a);
      agent_process(a);
      
      agent_eating(a);
      agent_locomotion(a);
      
      if (a.energy > 0) {
      	// still living for the next iteration:
      	newagents.push(a);
      	if (a.energy > reproduction_threshold) {
      		if (agents.length < max_population) {
				// give birth!
				var child = agent_new();
				// right next to us:
				child.pos = a.pos.clone();
				child.hue = wrap(a.hue + 0.1*(random()-0.5), 1);
				// share energy:
				a.energy *= 0.25;
				child.energy = a.energy;
				// add to new population:
				newagents.push(child);
			} else {
				//write("too many agents!");
			}
      	}
      }
  }
  // update with new population:
  agents = newagents;
  
  // re-seed?
  if (agents.length < 1) {
  	agents.push(agent_new());
  }
  
  // get the total energy in the system:
  var energy = food.sum();
  for (var a of agents) {
  	energy += a.energy;
  }
  write("total", energy);
  
  // now redistribute the entropy to the world:
  var energy_deficit = Math.max(0, world_energy - energy);
  var max_deposit = 10;
  while (energy_deficit > max_deposit) {
  	food.deposit(max_deposit, new vec2((now * 0.1) % 1, random()));
  	//food.add(10/(dim*dim));
  	energy_deficit -= max_deposit;
  }
  
  write("population", agents.length);
}

function draw() {
  food.draw();

  for (var a of agents) {
    draw2D.push()
      .translate(a.pos)
      .rotate(a.dir)
      .scale(a.size);
    // use hue, saturation, lightness to show state:
    draw2D.hsl(a.hue, a.energy, 0.5)
      .triangle();
    // sensor (shows current state by color)
    draw2D.hsl(a.hue, a.sensor[0], 0.5)
  	  .circle([sensor_size, sensor_size], 0.5);
    draw2D.hsl(a.hue, a.sensor[1], 0.5)
  	  .circle([sensor_size,-sensor_size], 0.5);
    draw2D.pop();
  }
}

function mouse(e, p) {
	if (e == "down") {
		var seed = agent_new();
		seed.pos.set(p);
		agents.push(seed);
	}
}
    </script>
  </body>
</html>