<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <script src="al.js"></script>
    <script>
// the desired result:
var target = "the quick brown fox jumped over the lazy dog";

// the set of components:
var dictionary = ["I", "a", "an", "bleep", "blown", "bog", "box", "broad", "brown", "bumped", "cat", "cog", "coloured", "colourful", "colourless", "crazy", "creep", "crown", "dig", "do", "dog", "door", "dot", "ever", "fit", "fix", "flick", "for", "fox", "frown", "glean", "great", "greed", "green", "greet", "hazy", "he", "hog", "ideas", "idols", "in", "it", "jumble", "jumped", "jumper", "jumps", "last", "lazy", "leaped", "lumped", "maze", "of", "offer", "ogre", "older", "on", "or", "over", "quick", "quite", "rapid", "she", "sheen", "sheep", "sick", "sleep", "slept", "slow", "spelt", "spilt", "the", "town", "under"];


// how many candidates in a generation:
var pop_size = 80;
// the base probability of mutations:
var gene_mutation_rate = 0.7;

// initialize:
var generation = 0;
// generate a random population:
var pop = [];
for (var i = 0; i < pop_size; i++) {
	var geno = [];
	for (var j=0; j < 9; j++) {
		geno[j] = random(dictionary.length);
	}
	pop.push(geno);
}

function develop(geno) {
	var pheno = [];
	for (var i=0; i < geno.length; i++) {
		pheno[i] = dictionary[ geno[i] ];
	}
	return pheno.join(" ");
}

function geno_eval(geno) {
	var pheno = develop(geno);
	
	geno.str = pheno;
	
	var err = 0;
	for (var i=0; i < pheno.length; i++) {
		if (pheno.substr(i, 1) != target.substr(i, 1)) {
			err++;
		}
		// and backwards too?
		if (pheno.substr(pheno.length-1-i, 1) != target.substr(target.length-1-i, 1)) {
			//err++;
		}
	}
	
	geno.fitness = 1 / (1 + err/pheno.length);
}

function update() {
	// evaluate each member of the gene pool:
	for (var i = 0; i < pop_size; i++) {
		geno_eval(pop[i]);
	}
	
	// sort by fitness:		
	pop.sort(function(a, b) { return b.fitness - a.fitness; });
	
	// show them:
	for (var i = 0; i < pop_size; i++) {
		write(generation, i, pop[i].fitness, pop[i].str);
	}
	
	// make a new generation:
	var newpop = [];
	for (var i = 0; i < pop_size; i++) {
		// fitter candidates are less volatile:
		var mutability = i/pop_size * gene_mutation_rate;	
		
		var child = [];
		
		// pick a parent (by using random(i) we bias to fitter parents)
		var parent = pop[random(i)];
		
		// an alternative using proximity
		//var idx = i + random(9)-5;
		//idx = Math.min(Math.max(idx, 0), pop_size-1);
		//var parent = pop[ idx ];
		
		// copy or mutate genes:
		for (var j = 0; j < parent.length; j++) {
			// mutate?
			if (random() < mutability) {
				child[j] = random(dictionary.length); 
			} else {
				// copy:
				child[j] = parent[j]
			}
		}
		
		// add to population:
		newpop[i] = child;
	}
	
	// replace:
	pop = newpop;
	generation++;
}

console.log(pop);

var n = new field2D(10);
n.set(function() { return random(); });

var tri = draw2D.shape([ 
	[-1, -1], [1, -1], [1, 1]
]);

function draw() {
	draw2D.color("green");
	//draw2D.push().translate([0.5, 0.5]).scale(0.5);
	draw2D.triangle([0.5, 0.5]);
	//draw2D.pop();
	
	draw2D.texture(n);
	draw2D.color("red");
	draw2D.triangle([0, 0], [1, 1], [1, 0]);
	
	
	//draw2D.texture();
	draw2D.color("yellow");
	tri([0.5, 0.5]);
}

/*
// the value we are trying to compute:
var target = Math.PI;
// the alphabet of symbols our code can use:
var symbols = ["+", "-", "*", "/", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"];
//var symbols = [".", "*", "1", "2"];
// this determines how many values a gene can take on:
var gene_range = symbols.length;
// how many genes in a genome:
var gene_size = 10;
// how many candidates in a generation:
var pop_size = 80;
// the base probability of mutations:
var gene_mutation_rate = 0.1;

// initialize:
var generation = 0;
// generate a random population:
var pop = [];
for (var i = 0; i < pop_size; i++) {
	var geno = [];
	for (var j = 0; j < gene_size; j++) {
		geno[j] = random(gene_range);
	}	
	pop.push(geno);
}

function develop(geno) {
	// convert genotype into phenotype (a string of code)
	var pheno = ["return "];
	for (var i = 0; i < gene_size; i++) {
		pheno.push( symbols[geno[i]] );
	}
	return pheno.join("");
}

function geno_eval(geno) {
	// develop the genotype into a phenotype of code:
	var code = develop(geno);
	// store for later printing
	geno.code = code;	
	// default fitness is zero (in case there is an error below)
	geno.fitness = 0;
	// put into try block because random code can cause errors!
	try {
		// create an executable function from the code
		var test = new Function(code);
		// run it
		var result = test();
		geno.result = result;
		// throw out unusable values (last case checks for NaN)
		if (result != Infinity && result != -Infinity && result == result) {
			// convert this into a fitness scale of 0..1
			geno.fitness = 1 / (1 + Math.abs(target - result));
		}
	} catch (e) {
	//	console.log(e);
	}
}

function update() {
	// evaluate each member of the gene pool:
	for (var i = 0; i < pop_size; i++) {
		geno_eval(pop[i]);
	}
	
	// sort by fitness:		
	pop.sort(function(a, b) { return b.fitness - a.fitness; });
	
	// show them:
	for (var i = 0; i < pop_size; i++) {
		write(generation, i, pop[i].fitness, pop[i].result, pop[i].code);
	}
	
	// make a new generation:
	var newpop = [];
	for (var i = 0; i < pop_size; i++) {
		// fitter candidates are less volatile:
		var mutability = i/pop_size * gene_mutation_rate;	
		
		var child = [];
		
		// pick a parent (by using random(i) we bias to fitter parents)
		var parent = pop[random(i)];
		
		
		// an alternative using proximity
		//var idx = i + random(9)-5;
		//idx = Math.min(Math.max(idx, 0), pop_size-1);
		//var parent = pop[ idx ];
		
		
		// copy or mutate genes:
		for (var j = 0; j < gene_size; j++) {
			// mutate?
			if (random() < mutability) {
				child[j] = random(gene_range); 
			} else {
				// copy:
				child[j] = parent[j]
			}
		}
		
		// add to population:
		newpop[i] = child;
	}
	
	// replace:
	pop = newpop;
	generation++;
}
*/
/*
var test
try {
	var test = new Function('return 1 + ');
	var r; 
	r = test();
} catch (e) {
	console.log(e);
}

console.log(r);
*/

/*
// general form: a function mapping [x,y] to [r, g, b]
var img = new field2D(200);
var img_copy = img.clone();

img.set(function() {
	return [random(), random(), random()];
});

var center = new vec2(0.5, 0.5);

function update() {
	var tmp = img_copy;
	img_copy = img;
	img = img_copy;

	img.update(function(v, p) {
		var r = (random() - 0.5)*2;
		r = r * r * r;
		var p1 = p.copy().sub(center).rotate(Math.PI / 8).add(center);
		var p2 = p1.copy().add(vec2.random(0.02*r));
		var p3 = p1.copy().add(new vec2(1/4, 1/3));
		p3.lerp(p2, p[1]);
		return img_copy.sample(p3);
		//return [img_copy.sample(p3, 0), img_copy.sample(p2, 1), img_copy.sample(p1, 2)];
	});
	//img.diffuse(img_copy, 0.01);
	img.normalize();	
}

function draw() {
	img.draw();
}

*/

/* 
var target = "artificial life";

var genome_size = target.length;

// Encoding: a genotype is a sequence of letters
var encoding = [ " ", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z" ];
// range of valid values of a gene
var gene_range = encoding.length;

// chance of mutation:
var mutation_rate = 0.05;
// size of a mutation (how many steps in either direction it can go):
var mutation_range = 10;

// our population
var pop = [];
// size of population:
var population_size = 20;

// true until we find a satisfying result:
var searching = true;



// generate a random genotype:
function geno_new() {
	var g = [];
	for (var i = 0; i < genome_size; i++) {
		g[i] = random(gene_range);
	}
	return g;
}

// generate a phenotype from the genotype:
function geno_develop(g) {
	var p = [];
	for (var i = 0; i < g.length; i++) {
		var gene = g[i];
		p[i] = encoding[ gene ];
	}
	return p;
}

// evaluate a phenotype:
function pheno_eval(p) {
	var result = p.join("");
	// score according to how near it is to the target:
	var err = 0
	for (var i = 0; i < p.length; i++) {
		var letter = p[i];
		if (letter != target.substring(i, i+1)) {
			err++;
		}
	}
	var fitness = 1 / (1 + err);
	return fitness;
}
	
// run the simulation:
function initialize() {
	// re-initialize:
	generation = 1;
	pop = [];
	// create population:
	for (var i = 0; i < population_size; i++) {
		pop[i] = geno_new();
	}
}
initialize();

// click to restart
function mouse(e, p) {
	if (e == "down") initialize();
}

// run each generation:
function regenerate() {
	
	// develop, evaluate & annotate each candidate:
	for (var i=0; i<pop.length; i++) {
		var g = pop[i];
		var p = geno_develop(g);
		var fitness = pheno_eval(p);
		// store annotation:
		g.fitness = fitness;
		g.pheno = p.join("");
	}
	
	// sort the population by fitness:
	pop.sort(function(a, b) {
		return b.fitness - a.fitness;
	});
	
	// show it:
	write("generation", generation, "------------------------")
	for (var i = 0; i<pop.length; i++) {
		var g = pop[i];
		write(i, g.pheno, "fitness:", g.fitness)
	}
	
	// terminating condition:
	if (pop[0].fitness == 1) {
		searching = false;
	} else {
		
		// create a new population:
		var newpop = [];
		for (var i=0; i<population_size; i++) {
			// crossover:
			var mum = pop[random(i)];
			var dad = pop[random(i)];
			var child = [];
		
			// crossover reproduction:
			var cross = random(genome_size)
			for (var j = 0; j < cross; j++) {
				child[j] = mum[j]
			}
			for (var j = cross; j < genome_size; j++) {
				child[j] = dad[j]
			}
			// apply mutation:
			for (var j = 0; j < child.length; j++) {
				var gene = child[j];
				// mutate?
				if (random() < mutation_rate) {
					// mutate plus or minus N:
					gene = gene + (random(mutation_range*2+1)-mutation_range)
					// bring back into range:
					gene = wrap(gene, gene_range); 
					// store:
					child[j] = gene
				}
			}
			// TODO: other kinds of mutation: shuffling, reversing, etc.
			newpop[i] = child
		}
		// replace:
		pop = newpop
	
		generation++;
	}
}

function update() {
	if (searching) regenerate();
}
*/
    </script>
  </body>
</html>